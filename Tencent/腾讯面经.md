1. ### 上来就说jvm

2. ### 多线程的实现方法

   1.继承Thread类，重写run方法

   2.实现Runnable接口，重写run方法，实现Runnable接口的实现类的实例对象作为Thread构造函数的target

   3.通过Callable和FutureTask创建线程

   4.通过线程池创建线程

   

3. ### springMVC框架说一下

   Spring MVC和Spring Boot都属于Spring，Spring MVC 是基于Spring的一个 MVC 框架，而Spring Boot 是基于Spring的一套快速开发整合包

   

4. ### 然后接口与抽象类的区别

   语法层面上的区别

   　　1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；

   　　2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；

   　　3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；

   　　4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。

   

5. #### 数据库， 提高查询速度

   1、缓存，在持久层或持久层之上做缓存

   使用ehcache缓存,这个一般用于持久层的缓存，提供持久层、业务层的快速缓存，hibenate默认使用的二级缓存就是ehcache;

   2、数据库表的大字段剥离

   假如一个表的字段数有100多个,学会拆分字段,保证单条记录的数据量很小;

   3、恰当地使用索引

   必要时建立多级索引,分析MySQL的执行计划，通过表数据统计等方式协助数据库走正确的查询方式，该走索引就走索引，该走全表扫描就走全表扫描;

   4、表的拆分

   表分区和拆分，无论是业务逻辑上的拆分（如一个月一张报表、分库）还是无业务含义的分区（如根据ID取模分区）;

   5、字段冗余

   减少跨库查询和大表连接操作;,数据通过单个或多个JOB生成出来，减少实时查询;

   6、从磁盘上做文章

   数据存放的在磁盘的内、外磁道上，数据获取的效率都是不一样的;

   7、放弃关系数据库的某些特性

   引入NoSQL数据库;

   换种思路存放数据，例如搜索中的倒排表;

   “

   **在上面谈到数据库查询速度优化方案我们讲到了,数据优化的几种方案。接下来,一起看如何实际到具体的操作上.也就是我们在写数据时我们应该注意些什么？**

   1、对查询进行优化,应尽可能避免全表扫描

   首先应考虑在 where 及 order by 涉及的列上建立索引。

   下面我们来以一个表中177条数据比较一下,全表扫描与建立索引之后性能的一个比较.

   1.1 全表查询

   

   ![img](https:////upload-images.jianshu.io/upload_images/2847398-e5e78bbc59e310c7)

   

   1.2 建立索引查询

   

   ![img](https:////upload-images.jianshu.io/upload_images/2847398-2ed4bfe89c6da1b6)

   

   1.3 结论

   从这两种方式查询数据库结果看,建立索引之后查询速度提高了些,现在数据量还不明显,如果表中有10万条速度,差异就会很明显了.

   2、写数据语句时尽可能减少表的全局扫描

   2.1 减少where 字段值null判断

   

   ![img](https:////upload-images.jianshu.io/upload_images/2847398-813f2205de2729ba)

   

   如何这样做,就会导致引擎放弃使用索引而进行全表扫描

   应该这样去设置(也就是在没有值时,我们在存数据库时自动默认给个o值,而不是什么都不写):

   

   ![img](https:////upload-images.jianshu.io/upload_images/2847398-3de8dcfed6c1501f)

   

   2.2 应尽量避免在 where 子句中使用!=或<>操作符

   

   ![img](https:////upload-images.jianshu.io/upload_images/2847398-8df631fa3620cd91)

   

   这样写将导致引擎放弃使用索引而进行全表扫描。

   2.3 应尽量避免在 where 子句中使用 or 来连接条件

   

   ![img](https:////upload-images.jianshu.io/upload_images/2847398-0de430a725cefc37)

   

   这样将导致引擎放弃使用索引而进行全表扫描

   可以这样操作:

   

   ![img](https:////upload-images.jianshu.io/upload_images/2847398-ce12358b08063b93)

   

   2.4 in 和 not in 也要慎用

   

   ![img](https:////upload-images.jianshu.io/upload_images/2847398-ee40b3a9f381c96e)

   

   这样操作,也会导致全表扫描

   

   ![img](https:////upload-images.jianshu.io/upload_images/2847398-6ee6d637b8d32052)

   

   以通配符*去查询所有数据,这样做也是非常耗时的,我们应该需要什么字段就查询什么字段.

   应该这样做:

   

   ![img](https:////upload-images.jianshu.io/upload_images/2847398-b84703b1e533fe81.png)

   

   3、不要在条件判断时进行 算数运算

   

   ![img](https:////upload-images.jianshu.io/upload_images/2847398-9820b524c834baa4.png)

   

   所以不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算,这样系统将可能无法正确使用索引

   应该这样做:

   

   ![img](https:////upload-images.jianshu.io/upload_images/2847398-56bcbbfa4df32917.png?)

   

   4、很多时候用 exists 代替 in 是一个好的选择

   

   ![img](https:////upload-images.jianshu.io/upload_images/2847398-1b2de7f1c77f5ba1)

   

   5 论索引技巧

   5.1 并不是所有索引对查询都有效

   SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。

   5.2 索引并不是越多越好

   索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。

   5.3 应尽可能的避免更新 clustered 索引数据列

   因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。

   5.4 尽量使用数字型字段

   若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。

   5 创建数据库时应该注意地方

   5.1. 尽可能的使用 varchar/nvarchar 代替 char/nchar

   因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。

   5.2 用表变量来代替临时表。

   \1. 如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。

   \2. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。

   \3. 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。

   \4. 避免频繁创建和删除临时表，以减少系统表资源的消耗。

   \5. 尽量避免使用游标

   \1. 因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。

   \2. 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。

   \3. 与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。

   6 数据放回时注意什么

   6.1 尽量避免大事务操作，提高系统并发能力。

   这样可以有效提高系统的并发能力

   6.2 尽量避免向客户端返回大数据量

   若数据量过大，应该考虑相应需求是否合理。

6. #### mylsam，innodb，

7. ## InnoDB与Myisam的六大区别

   

   |                                        | **MyISAM**                                                   | **InnoDB**                                                   |
   | -------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | **构成上的区别：**                     | 每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。    .frm文件存储表定义。    数据文件的扩展名为.MYD (MYData)。    索引文件的扩展名是.MYI (MYIndex)。 | 基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB |
   | **事务处理上方面:**                    | MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持 | InnoDB提供事务支持事务，外部键等高级数据库功能               |
   | **SELECT   UPDATE,INSERT，Delete操作** | 如果执行大量的SELECT，MyISAM是更好的选择                     | **1.**如果你的数据执行大量的**INSERT或UPDATE**，出于性能方面的考虑，应该使用InnoDB表    **2.DELETE   FROM table**时，InnoDB不会重新建立表，而是一行一行的删除。    **3.LOAD   TABLE FROM MASTER**操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用 |
   | **对AUTO_INCREMENT的操作**             | 每表一个AUTO_INCREMEN列的内部处理。    **MyISAM为INSERT和UPDATE操作自动更新这一列**。这使得AUTO_INCREMENT列更快（至少10%）。在序列顶的值被删除之后就不能再利用。(当AUTO_INCREMENT列被定义为多列索引的最后一列，可以出现重使用从序列顶部删除的值的情况）。    AUTO_INCREMENT值可用ALTER TABLE或myisamch来重置    对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引    更好和更快的auto_increment处理 | 如果你为一个表指定AUTO_INCREMENT列，在数据词典里的InnoDB表句柄包含一个名为自动增长计数器的计数器，它被用在为该列赋新值。    自动增长计数器仅被存储在主内存中，而不是存在磁盘上    关于该计算器的算法实现，请参考    **AUTO_INCREMENT列在InnoDB里如何工作** |
   | **表的具体行数**                       | select count(*) from table,MyISAM只要简单的读出保存好的行数，注意的是，当count(*)语句包含   where条件时，两种表的操作是一样的 | InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行 |
   | **锁**                                 | 表锁                                                         | 提供行锁(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non-locking read in    SELECTs)，另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%” |

8. ### 说了B+树，问B+树为什么找的快

   ## 七、为什么说B+树比B树更适合数据库索引？

   1、 **B+树的磁盘读写代价更低**：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。

   2、**B+树的查询效率更加稳定**：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

   3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。

   PS：我在知乎上看到有人是这样说的,我感觉说的也挺有道理的：

   他们认为数据库索引采用B+树的主要原因是：B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。

9. ### 数据库的优化有没有这方面的经验 

   （详见问题5）

10. ### 先说了区块链区块链得共识机制，基于什么密码方案，密码方案基于什么困难问题

11. ### 对称加密，非对称加密，都有哪些密码体系，区块链在未来有什么你看好的。 

12. ### tcp 3次握手 

    ​	三次握手(我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功)：

    - 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
    - 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
    - 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

    　　　　　　　　　　　　![三次握手.png-12.4kB](http://static.zybuluo.com/Rico123/c7m5fo6qdua0q7me88jm9w10/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

    

13. ### 数据库连接池怎么设计 

    

14. ### 句柄泄露 

15. ### Syn flood 

    当一个客户端尝试和一个服务器建立TCP连接，客户端和服务端会交换一系列报文。 这种连接技术广泛的应用在各种TCP连接中，例如telnet,Web,email,等等。 
    首先是客户端发送一个SYN报文给服务端，然后这个服务端发送一个SYN-ACK包以回应客户端，接着，客户端就返回一个ACK包来实现一次完 整的TCP连接。在服务端返回一个确认的SYN-ACK包的时候有个潜在的弊端，他可能不会接到客户端回应的ACK包。这个也就是所谓的半开放连接，服务端需要耗费一定的数量的系统内存来等待这个未决的连接，虽然这个数量是受限的，但是恶意者可以通过创建很多的半开放式连接来发动SYN洪水攻击 。
    通过ip欺骗可以很容易的实现半开放连接。攻击者发送SYN包给服务端系统，这个看起来是合法的，但事实上所谓的客户端根本不会回应这个 。SYN-ACK报文，这意味着服务端将永远不会接到ACK报文。 而此时，半开放连接将最终耗用受害者所有的系统资源，受害者将不能再接收任何其他的请求。通常等待ACK返回包有超时限制，所以半开放 。
    连接将最终超时，而受害者系统也会自动修复。虽然这样，但是在受害者系统修复之前，攻击者可以很容易的一直发送虚假的SYN请求包来持续攻击。 在大多数情况下，受害者几乎不能接受任何其他的请求，但是这种攻击不会影响到已经存在的进站或者是出站连接。虽然这样，受害者系统 还是可能耗尽系统资源，以导致其他种种问题。 
    攻击系统的位置几乎是不可确认的，因为SYN包中的源地址多数都是虚假的。当SYN包到达受害者系统的时候，没有办法找到他的真实地址 ，因为在基于源地址的数据包传输中，源ip过滤是唯一可以验证数据包源的方法。 

16. ### 两链表相交，求相交节点 

    ```java
    public class Solution {
        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
            int lenA = length(headA);
            int lenB = length(headB);
            
    
      while(lenA>lenB){
           headA = headA.next;
            lenA--;
        }
        
        while(lenB>lenA){
            headB = headB.next;
            lenB--;
        }
        
        while(headA!=null){
            if(headA == headB){
                return headA;
            }
            headA = headA.next;
            headB = headB.next;
        }
        
        return null;
    }
    
    public int length(ListNode node){
        int length = 0;
        while(node!=null){
            length++;
            node = node.next;
        }
        return length;
    }
    
    }
    ```

    

17. ### 怎么判断一个数是不是2的幂 

    二进制里只有一个1

18. ### 判断一个数的二进制里面有多少个1 

    %2 然后右移

19. ### 无重复字符的最长子串 

```java
public int lengthOfLongestSubstring(String s) {
    int i = 0, j = 0, max = 0;
    Set<Character> set = new HashSet<>();
    
    while (j < s.length()) {
        if (!set.contains(s.charAt(j))) {
            set.add(s.charAt(j++));
            max = Math.max(max, set.size());
        } else {
            set.remove(s.charAt(i++));
        }
    }
    
    return max;
}
```

19. ### tcp3 次握手    

20. ​	三次握手(我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功)：

    - 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
    - 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
    - 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

    　　　　　　　　　　　　![三次握手.png-12.4kB](http://static.zybuluo.com/Rico123/c7m5fo6qdua0q7me88jm9w10/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

    

21. ### time_out状态  

22. ### Tcp和UDP区别  

    1.基于连接与无连接； 

    2.对系统资源的要求（TCP较多，UDP少）； 

    3.UDP程序结构较简单； 

    4.流模式与数据报模式 ；

    5.TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。

23. ### TCP协议如何保证可靠传输  

    TCP通过序列号、检验和、确认应答信号、重发控制、连接管理、窗口控制、流量控制、拥塞控制实现可靠性。

24. ### 拥塞避免的算法  

    慢开始、拥塞避免、快重传、快恢复

25. ### 慢查询  

    MySQL慢查询就是在日志中记录运行比较慢的SQL语句，这个功能需要开启才能用。

    在MySQL的配置文件my.cnf中写上：

    

    ```cpp
    long_query_time = 10
    log-slow-queries = /var/lib/mysql/mysql-slow.log
    ```

    long_query_time是指执行超过多久的SQL会被日志记录下来，这里是10 秒。
     log-slow-queries设置把日志写在那里（例子中慢查询日志会写到文件/var/lib/mysql/mysql-slow.log中），为空的时候，系统会给慢查询日志赋予主机名，并加上slow.log。如果设置了参数log-long-format ，那么所有没有使用索引的查询也将被记录。

    这是一个非常有用的日志。它对于性能的影响不大（假设所有查询都很快），并且强调了那些最需要注意的查询（丢失了索引或索引没有得到最佳应用）。

    

26. ### mysql主从同步  

27. ### 快速排序  

    ## 代码实现：

    ```java
    
    public class QuickSort {
        public static void quickSort(int[] arr,int low,int high){
            int i,j,temp,t;
            if(low>high){
                return;
            }
            i=low;
            j=high;
            //temp就是基准位
            temp = arr[low];
     
            while (i<j) {
                //先看右边，依次往左递减
                while (temp<=arr[j]&&i<j) {
                    j--;
                }
                //再看左边，依次往右递增
                while (temp>=arr[i]&&i<j) {
                    i++;
                }
                //如果满足条件则交换
                if (i<j) {
                    t = arr[j];
                    arr[j] = arr[i];
                    arr[i] = t;
                }
     
            }
            //最后将基准为与i和j相等位置的数字交换
             arr[low] = arr[i];
             arr[i] = temp;
            //递归调用左半数组
            quickSort(arr, low, j-1);
            //递归调用右半数组
            quickSort(arr, j+1, high);
        }
     
     
        public static void main(String[] args){
            int[] arr = {10,7,2,4,7,62,3,4,2,1,8,9,19};
            quickSort(arr, 0, arr.length-1);
            for (int i = 0; i < arr.length; i++) {
                System.out.println(arr[i]);
            }
        }
    }
    
    ```
    
28. ### jvm垃圾回收  

    (详见java／jvm和垃圾回收)

29. ### 抽象类和接口的区别  

    （详见4）

30. ### String 和 StringBuilder和StringBuffer的区别  

    答：Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰（非同步），因此它的效率也比StringBuffer要高。

    面试题1：什么情况下用+运算符进行字符串连接比调用StringBuffer/StringBuilder对象的append方法连接字符串性能更好？
    面试题2：请说出下面程序的输出。

    ~~~java
    class StringEqualTest {
        public static void main(String[] args) {
            String s1 = "Programming";
            String s2 = new String("Programming");
            String s3 = "Program";
            String s4 = "ming";
            String s5 = "Program" + "ming";
            String s6 = s3 + s4;
            System.out.println(s1 == s2); // false
            System.out.println(s1 == s5); // true
            System.out.println(s1 == s6); // false
            System.out.println(s1 == s6.intern()); // true
            System.out.println(s2 == s2.intern()); // false
        }
    }
    ~~~
    
    补充：解答上面的面试题需要清除两点：
    
    String对象的intern方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与String对象的equals结果是true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用。
字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象，这一点可以用javap -c StringEqualTest.class命令获得class文件对应的JVM字节码指令就可以看出来。
    要想获取对象的内存地址应使用System.identityHashCode()方法。

31. ### HashMap的区别  

    

32. ### 介绍一下自己的项目  

33. ### 两个香，一根燃烧1小时。怎么确定一个15分钟  

首先想到如果一根香首尾同时点燃，烧完的时间为整根香的一半，也就是30分钟。

如果有一根香烧完的时间是30分钟，那么首尾同时点燃烧完的时间为15分钟。

正好还有一根香，但是烧完的时间是一个小时，怎样能让它烧完的时间为30分钟呢？

第一根香首尾点燃同时，将第二根香从一端点燃，第一根香烧完时为30分钟，第二根香离烧完还有30分钟，此时将第二根香另一端也点燃，第二根香燃尽的时间就是15分钟了。

33. ### 一个矩形里面套着一个矩形，怎么一刀平分

    找两个矩形的中点

    

34. ### 重载和重写的区别； 

    **重载(overload)：**
    方法重载是指同一个类中的多个方法具有相同的名字,但这些方法具有不同的参数列表,即参数的数量或参数类型不能完全相同;
    **重写(override)：**
    方法重写是存在子父类之间的,子类定义的方法与父类中的方法具有相同的方法名字,相同的参数表和相同的返回类型；
    需要注意的是，被final修饰的方法不能重写；抽象类和接口的方法必须要重写。

35. ### Java中默认修饰符； 

    1. 类（class）

    可见性修饰符： **public—**在所有类中可见，在其他包中可以用import导入。

    ​          				**缺省—**就是没有修饰符，在同一个包中的类中可见，在其他包中不能用import导入。

    ​              修饰符：**final**—终态类，表示该类不能被继承

    ​                            **abstract—**抽象类，不能新建对象

    2. 变量（variable）

    Java中变量有两种，方法变量和字段变量

    方法变量只能用一个修饰符：**final**—表示常量，不能修改

    下面是字段变量的修饰符

    ​        可见性修饰符：**public**—在任何类中可见

    ​                             **protected**—       在子类中或同一个包中可见

    ​                             **private**—只在本类中可见，子类中也不可见

    ​                             **缺省—**在同一个包中可见，子类不在一个包中，子类中也不可见  

    ​        修饰符：**static**—静态变量，被类的所有实例共享

    ​                      **final**—常量，定义后不能修改

    ***transient**—告诉编译器，在类对象序列化的时候，此变量不需要持久保存

    ***volatile**—指出可能有多个线程修改此变量，要求编译器优化以保证对此变量的修改能够被正确的处理

    这两带*的不是很常用，但也是Java的修饰符，我也不是很清楚

    

    3.方法(method)

       可见性修饰符：**public**—在任何类中可见

    ​                             **protected**—在子类中或同一个包中可见

    ​                             **private**—只在本类中可见，子类中也不可见

    ​                                   **缺省—**在同一个包中可见，子类不在一个包中，子类中也不可见

       修饰符： **static**—静态方法，并不需要创建类的实例就可以访问静态方法

    ​                      **final**—常方法，所有子类不能覆盖该方法，但可以重载

    ​                      **abstract**—抽象方法，在抽象类中没有实现的方法

    ​                      **native**—本地方法，参见Java Native Interface(JNI)

    **synchronized —**在多线程中，synchronized方法调用时，其他所有方法不能调用该方法

    

    \3.       接口（interface）

    ​         可见性修饰符：**public**—所有类中可见

    ​                       **缺省**—同一个包中可见

    ​         接口中的变量总是需要定义为“ **public static final** 接口名称”，但可以不包含这些修饰符，编译器默认就是这样  

    ​     

    ​         接口中的方法只能使用**public**和**abstract**修饰符    

36. ### Protected的权限范围； 

    在子类中或同一个包中可见

    

37. ### HashMap在什么情况下会导致不安全？ 

    HashMap是线程不安全的

    Collections.synchronizedMap(HashMap map)方法使HashMap具有同步的能力。

    

38. ### 由上一个问题引出HashMap为什么会产生循环链表； 

    会

    头插法

    扩容

    两个线程插入 key 为1，3 的entry

    t1插入1，3 t2 再插入时扩容，造成死循环

39. ### Sychronized和ReentrantLock说一说。原理、区别之类的； 

    java 多线程

40. ### CAS和AQS的原理； 

    java 多线程

41. ### 从JVM方面说说如果发生了死锁，怎么从JVM里找原因； 

    

42. ### JAVA死锁怎么解决？ 

    jstack -l jvm_pid

     

    运行以下代码之后运行上面命令，可以在控制台上看到死锁。

43. ### JUC包有什么熟悉的； 

44. ### 数据库索引说一说，覆盖索引、联合索引等； 

    如果一个索引包含所有需要查询的字段，就称之为“覆盖索引”。由于在索引的叶子节点中已经包含了要查询的全部数据，所以就可以从索引中直接获取查询结果，而没必要再回表查询。

45. ### 数据库联合索引的建立原理； 

  

46. ### 给一些语句，会不会用到索引； 

    

47. ### 怎么判断一些语句用没用到索引； 

    MySQL的Explain关键字查看是否使用索引

    

48. ### 2个大文件，每个文件50亿条URL，每个URL64B，内存4G，怎么找出所有重复项； 

    map reduce 策略，拆分 大文件，统计。然后reduce 把相同的加起来

49. ### HTTP是有状态还是无状态的？ 

    HTTP是一种无状态协议，即服务器不保留与客户交易时的任何状态。

    也就是说，上一次的请求对这次的请求没有任何影响，服务端也不会对客户端上一次的请求进行任何记录处理。

50. ### HTTP怎么变成有状态？ 

    两种用于保持HTTP状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session

51. ### GET和POST的区别？

      GET与POST是我们常用的两种HTTP Method，二者之间的区别主要包括如下五个方面：

      (1). 从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；

      (2). 从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；

      (3). 从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 请求头 中，以?分割URL和传输数据，参数之间以&相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 请求体 中。

      (4). 就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。

      (5). 从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。

      

52. ### 项目中优先级命令消息队列怎么实现，为什么用双向链表不用优先队列

53. ### 项目中使用udp为什么不使用tcp 

  ​    

54. ### 三次握手为什么是三次，四次挥手为什么是四次 

  ​    

55. ### 进程间通讯方式？（管道、消息队列、共享内存、信号、信号量、套接字通讯）管道、消息队列、共享内存、套接字通讯的特点和区别？ 

    **匿名管道( pipe )：**管道是一种半双工的通信方式，数据只能**单向流动**，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指**父子进程关系**。

    **高级管道(popen)：**将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。

    **有名管道 (named pipe) ：** 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。

    **消息队列( message queue ) ：** 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

    **信号量( semophore ) ：** 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

    **信号 ( sinal ) ：**进程间唯一的一种异步通信方式。

    **共享内存( shared memory ) ：**共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

    **套接字( socket ) ：** 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

    

56. ### 快排最坏情况复杂度？怎么解决这种情况？（三数取中） 

57. ### 介绍下面向对象的理解    

58. ### 开发过程中有用到过线程吗    

59. ### 说下线程池和普通线程的区别    

    线程池不会摧毁线程，而是放回线程池

60. ### 简单说下Activity的声明周期    

61. ### 了解过哪个生命周期内不适合做耗时操作吗 

    （Android）

62. ### 用过哪些数据存储方式 

63. ### 假如说多个线程同时往一个线程写入，如何保证文件不会被写乱掉（说保证线程安全）    

    保证线程安全

64. ### 了解过数据存储中SP存储的两个提交方法的不同    

65. ### 开发过程中遇到过内存泄露问题吗（说了handler的情况、静态和单例模式的情况、以及一些Bitmap资源的使用）    

66. ### 用过什么内存泄露的检测工具。    

67. ### 用过什么设计模式相关的内容（单例、AQS模板方法、RecyclerView的设置布局管理器的桥接模式等）    

68. ### 对打包过程的了解（我提了下签名，然后说我不记得了）    

69. ### 问常用的排序算法（选泡插、快归堆）然后问时间复杂度    

  ​    

70. ### HTTP和HTTPs区别    

71. ### get和post区别（作用、幂等性）    

72. ### 两个项目有什么挑战的地方   

    1. ### 两个栈实现一个队列    

    ```java
    class MyQueue {
        private Stack<Integer> in;
        private Stack<Integer> out; 
        /** Initialize your data structure here. */
        public MyQueue() {
            in = new Stack<Integer>();
            out = new Stack<Integer>();
        }
        
    
        /** Push element x to the back of queue. */
        public void push(int x) {
            while(out.size()>0){
                in.push(out.pop());
            }
            in.push(x);
            while(in.size()>0){
                out.push(in.pop());
            }
        }
    
        /** Removes the element from in front of queue and returns that element. */
        public int pop() {
            return out.pop();
        }
    
        /** Get the front element. */
        public int peek() {
            return out.peek();
        }
    
        /** Returns whether the queue is empty. */
        public boolean empty() {
            return out.size()==0;
        }
    
    }
    ```

73. ### 开始问其他的问题，用过HashMap、Hashtable等等

74. ### 问我DVM和JVM的区别。  

75. ### 最后写了一个常规题目，排序数组找两个值的和是目标值。  

76. ### 写完以后面试官说情况呢也了解的差不多了，问我有没有什么要问的，我就问了下进去蘑菇街需要主要学习点什么内容，面试官说没有什么特别需要学习的，说其实很多内容我们应该是会的，然后大概给我说了下蘑菇街的培养方式，说我可以看看蘑菇街的APP，揣摩下怎么去实现等等。  

77. ### 内存泄露以及怎么解决，内存泄露一定导致内存溢出吗，内存溢出和内存溢出的具体场景  

78. ### 软引用和弱引用的区别。  

    **弱引用**与**软引用**的区别在于：只具有**弱引用**的对象拥有**更短暂**的**生命周期**。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有**弱引用**的对象，不管当前**内存空间足够与否**，都会**回收**它的内存。不过，由于垃圾回收器是一个**优先级很低的线程**，因此**不一定**会**很快**发现那些只具有**弱引用**的对象。

    

79. ### 面向对象思想

    1. 对象
    2. 类
    3. 封装
    4. 继承
    5. 多态

80. ### xml 和 json使用的共同缺点  

81. ### 静态常量和静态变量分别是怎么加载的？  

    输出显示在打印静态常量时，StaticVar类并没有被加载，在输出静态变量的前才打印类加载信息。这表明类的未加载的情况下也能引用其静态常量信息，原因是因为常量值存储在JVM内存中的常量区中，在类**不加载**时即可访问。

    

82. ### ArrayList和LinkedList区别，ArrayList怎么扩容，复制的话有更好的方法吗？  

83. ### 线程池的原理

    1、线程池管理器（ThreadPool）：用于创建并管理线程池。包含 创建线程池，销毁线程池，加入新任务；
    2、工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态。能够循环的运行任务；
    3、任务接口（Task）：每一个任务必须实现的接口，以供工作线程调度任务的运行。它主要规定了任务的入口。任务运行完后的收尾工作，任务的运行状态等。
    4、任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。

84. ### 线程池的状态

    线程池的5种状态：Running、ShutDown、Stop、Tidying、Terminated。

    线程池各个状态切换框架图：
    ![这里写图片描述](https://img-blog.csdn.net/20180328153220367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR29HbGVUZWNo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
    1、RUNNING

    (1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。
    (02) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！

    ```
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));1
    ```

    2、 SHUTDOWN

    (1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。
    (2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -> SHUTDOWN。

    3、STOP

    (1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。
    (2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -> STOP。

    4、TIDYING

    (1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。
    (2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -> TIDYING。
    当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -> TIDYING。

    5、 TERMINATED

    (1) 状态说明：线程池彻底终止，就变成TERMINATED状态。
    (2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -> TERMINATED。

85. ### 线程池的使用有什么不好的地方？这部分面试官是想跟协程比较来着  

86. ### 线程和进程的关系？在操作系统上怎么体现的。

    一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.

    相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。

    

    线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.

    

87. ### 进程之间通信方式有哪些

  ​    

88. ### 线程的通信方式有哪些

  ​    

89. ### 线程安全有哪些实现方式

    ### 解决线程安全的四种方式：

    1、synchronized锁（偏向锁，轻量级锁，重量级锁）

    2、volatile锁，只能保证线程之间的可见性，但不能保证数据的原子性

    3、jdk1.5并发包中提供的Atomic原子类

    4、Lock锁

90. ### 两个进程，一个进程终止了，另外一个受影响吗

91. ### 两个进程之间哪些东西是独立的

    1、synchronized关键字修饰

    ```
    sychronized method(){} 
    
    sychronized (objectReference) {/*block*/} 
    
    static synchronized method(){} 
    
    sychronized(classname.class) 1234567
    ```

    前两者是该对象锁，后两者是类锁。

    2、定义常量。final static等

    3、使用ReentrantLock可重入锁

    

92. ### 10万个数字，找出最大的10个数

93. ### 堆排序、快排的时间复杂度

94. ### 说一下快排怎么实现的

95. ### hash排序（还是hash表，记不清了，没答出来）有什么特点

96. ### 说一下三次握手和time_wait状态

97. ### TCP通信怎么实现有序输入

98. ### 熟悉哪些linux命令

99. ### 用什么命令排查CPU的问题

100. ### 数据库查询有哪些方式可以加快查询速度（答的索引）

101. ### 除了索引，如果发现查询变慢了，应该怎么解决这个问题

102. ### 说一下linux的文件结构

103. ### 说一下项目中遇到的问题，怎么解决的 

104. ### map和set的区别 

105. ### 数据库用过哪些   说用过mysql，但是不会原理 

106. ### 删除表、删除表结构   瞎答的，不知道对不对 

107. ### 面试官看我不会数据库就说问最后一个问题，主键和外键 

108. ### 常用linux命令 

109. ### grep了解吗 

       Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。

110. ### 进程间通信方式 

     匿名管道( pipe )：**管道是一种半双工的通信方式，数据只能**单向流动**，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指**父子进程关系**。

     **高级管道(popen)：**将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。

     **有名管道 (named pipe) ：** 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。

     **消息队列( message queue ) ：** 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

     **信号量( semophore ) ：** 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

     **信号 ( sinal ) ：**进程间唯一的一种异步通信方式。

     **共享内存( shared memory ) ：**共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

     **套接字( socket ) ：** 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

111. ### 线程间同步方式 

     

112. ### ip、tcp、http分别在网络中的哪一层 

     

113. ### linux的定时怎么做  说听过timerfd  但是没用过

114. ### 一串1和0组成的数，相邻的不同的数可以消掉，问消掉之后字符串的长度 ，1100，消掉之后为0 

115. ### 一个满二叉树，结点数为2^k-1，每个结点的值为0~2^k-1，该二叉树还是排序树，找值=val1, val2, val3的节点的最小公共父节点。（这道题写了20分钟的时候还有一点bug，后面面试官让讲完思路之后才发现bug在哪里） 

116. ### 一堆硬币，形式是｛1, 1, 2, 2, 4, 4, 8, 8, 16, 16,...｝，问能凑成n的方案数，不能有重复的。 

117. ### n = 6，则方案数是3({1,1,2,2}, {2,4},{1, 1, 4}) 

118. ### 你现在把程序放在那，让他自己跑，你需要确保哪几个方面？如何做到？讲一下 

119. ### （我没答上来他想问的）于是，他又举例：内存占用角度？CPU角度？每S多少条数据？举例：每秒1000条数据和每秒10000条数据的时候，内存和CPU怎么对比？ 现在你导师找你做任务，告诉你机器的配置是多少，数据占了多少，CPU占了这么多条，你如何优化？后来答案不满意，他告诉我你对程序性能的理解，其实就是你对代码的理解。 

120. ### 数据存在云上，云是什么？你的数据是怎么存在云上的？在云上是什么样的数据结构？ 

121. ### 用过C/C++吗？C掌握程度什么样的？我说本科学了C现在自学了Java。好，说三个Java和c的区别？ 

122. ### Java有垃圾回收机制，c没有；Java是面向对象的语言，c是面向过程的语言；Java无法对内存控制，而C/C++可以通过指针对内存进行人为的分配。 

123. ### 说一下为什么JAVA有内存回收机制，而C没有？ 

124. ### （懵了）说创建一个对象都会放在新生代，然后怎么怎么回收，回收到老年代，最后就完成了一次垃圾回收。（面试官：好吧。后来告诉我说，就想听我说虚拟机三个字。） 

125. ### 对象是什么意思？ 

126. ### 网络攻击（xss、csrf） 

127. ### 性能优化（懒加载、缓存、重排重绘） 

128. ### 闭包 

129. ### cookie和localstorage区别 

130. ### http状态码 

131. ### 在地址栏里输入一个url到这个页面呈现出来，会发生什么？ 

132. ### DNS解析-tcp三次握手-http连接传输数据-服务端处理（返回304或200）-解析渲染dom

133. ### 跨域方案

134. ### 假如有个客户反馈说项目的页面加载时间过长，这时候你会怎么找出问题？   

135. ### 可能是用户的环境问题，服务端的问题，SQL的语句需要优化   

136. ### 怎么判断是用户的问题？怎么判断是服务端的问题？怎么判断是SQl语句需要优化？如果是SQL语句需要优化，那么要如何优化？SQL语句如何避免全局遍历（搜索）   

137. ### CSS的选择器了解么？   

138. ### 我问了如果要胜任你们公司的这个岗位需要哪些技术   

139. ### 面试官回答：大数据，node.js，redis数据库，后端技术使用的比较少，我对后端的了解也不是很多  

140. ### jvm G1和CMS区别 工作方式

141. ### 进程线程

142. ### IPC(管道 命名管道 消息队列 共享内存 socket)

143. ### unix domain socket知道吗？(面试官说这个是现在最常用的IPC方式）

144. ### 守护进程 怎么创建

145. ### TCP 死锁问题解决

146. ### reactor模式

147. ### 红黑树和AVL树区别 实现过吗？

     

148. ### 快速排序 时间复杂度分析 最坏 平均 怎么避免最坏时间复杂度

149. ### 读写锁场景题 Linux内核了解吗 顺序锁了解吗

150. ### epoll ET LT 边缘触发为什么会带来系统的提升和会带来什么问题

151. ### 熟悉那些数据库 mysql索引数据结构 B+ B 为什么使用B+树

152. ### 什么时候会使用B树 面试官说mongodb就是使用B树 你知道为什么吗？（？？？ 不知道）

153. ### 项目

154. ### 问了项目需求，框架，为什么这么设计，最后效果如何

155. ### 答的过程中提到曾经做过倒排索引，面试官就让我设计一个倒排索引的生成过程。要求写出每一步的输入输出，及计算思路

156. ### 倒排索引的增加和删除怎么做

157. ### kafka的整体架构

158. ### Kafka怎么保证exactly once

159. ### Kafka事务

160. ### 一道算法题 回溯法求组合

161. ### TCP time_wait状态

162. ### 概率题 54张牌 分成三堆 每堆18张 大小王出现在同一堆的概率

163. ### HTML跟HTML5的区别（面试官为我解释了本质区别，框架上的区别😅） 

164. ### TCP和UDP区别 

165. ### 写代码的时候应用到的数据结构，比如说二叉树、堆栈、队列等，你可以现在去百度然后告诉我（我写项目的时候确实没考虑过这些东西，唉，面试官都让我现场百度了） 

166. ### Mysql性能问题，数据量大时分表，你常用的mysql安装在哪儿。面对一批数据你怎么进行添加到数据库？ 

167. ### 你在面试的时候有没有觉得自己原本以为不重要的内容被问到了？或者说，面试你觉得是否是偏基础而不是偏向核心技术。 

168. ### 不算问题，面试官自述）实际工作里面落到每一行代码的时候，可能就是对于一些基本的数据结构的理解以及数据类型判断，然后让你踩到一些小坑导致整个程序的close或者down。这种情况在那种大的框架设计上就会出现大问题，所以说不会问你一些大的问题，基本问的都是小问题，因为毕业生的话，我觉得你要有一个好的基础才能让你以后走得更远，就像我刚刚让你直接去百度找资料一样，如果你有学习能力的话，你就学得非常快，成长得很快。（提到JS高程）书应该是工具，你没必要去记住每一个细节，你可以在遇到不会的时候去查 

169. ### （大多数时候都是面试官在说，他为我分析了我项目上的一些东西，对我的项目进行了评价。另外面试官每次问问题，都会自己先分析一下，然后再问问我的看法。虽然我面试的次数不算多，但这个面试官给我的感觉非常好，他在教我怎么去思考、学习、总结，以及帮我纠正我在前端上走的歪路。不管结果怎么样，我非常的感谢。🤣）

170. ### linux清空文本内容的语句 

171. ### 测试微信发朋友圈 

172. ### python 单例模式 

173. ### python: 列表和元组的区别、模块导入、三元表达式、爬虫相关  

174. ### 操作系统：CPU调度算法

175. ### 操作系统：分页算法

176. ### 操作系统：操作系统类型

177. ### 操作系统：进程与线程的区别  

  ​      

178. ### 前端：通用的CSS库，CSS控制元素、js如何与后台进行连接、有没有用过JQuery  

179. ### 数据库：范式、数据库存储过程、慢查询、数据库索引、数据库引擎  

180. ### 算法：英文句子 单词逆序输出，考虑优化算法  

181. ### 其他：项目中遇到的问题以及收获，对测试的看法，看过哪些书，实习时间

182. ### 循环引用在内存中会被自动垃圾回收吗 

     java中循环引用会不会防止GC回收

     在函数的结尾，a和b的计数均为2
     先撤销a，然后a的计数为1，在等待b.a对a的引用的撤销，也就是在等待b的撤销
     对于b来讲，也是同理
     两个对象都在等待对方撤销，所有这两个资源均不能释放

     

183. ### 500w长度字符串，使用asci字符集，找到第一个重复的字符 

184. ### 实现方法，最坏时间空间复杂度，比较次数 

185. ### 字符集不限定，改为一个字符4个字节，最坏时间复杂度，使用空间大小，比较次数 

186. ### 全局变量和局部变量介绍 bss/栈/静态    

187. ### 栈区堆区静态区介绍   

188. ### 会造成什么 tcp三次握手 和 四次挥手 流量控制 拥塞控制 time_wait时间长度    

189. ### tcp和udp 应用场景    

190. ### 为什么要有time_wait 进程间通信方式 管道怎么用 C++虚类和非虚类区别    

191. ### select poll epoll 简介 / epoll的两种工作模式    

192. ### vector 和 map 实现方式    

193. ### pthread    

194. ### 死锁 资源锁    

195. ### 共享内存 mmap shm    

196. ### 数据库事物隔离    

197. ### http和https简介    

198. ### 数据库注入问题描述及解决办法    

     

199. ### Java 反序列化原理    

200. ### shell？    

201. ### 快速排序 堆排序 算法原理 以及 时间复杂度 空间复杂度分析    

202. ### mysql事务隔离级别

     1.读未提交（READ UNCOMMITTED）

     2.读已提交（READ COMMITTED）

     3.可重复读（REPEATABLE READ）

     4.可串行化（SERIALIZABLE）

203. ###  大数据表优化    

204. ### 浏览器地址输入一个域名之后所有的过程    

205. ### 常用设计模式    

206. ### 手撕代码：字符串解密（https://www.nowcoder.com/questionTerminal/c27561e5b7e0441493adb9a54071888d    

207. ### 进程间通信机制    

208. ### xss描述/数据库注入描述    

209. ### 内存池 实现 以及评价标准   

210. ### 内存碎片处理（回答二分堆    

211. ### mysql 数据库引擎 innodb MyISML    

212. ### 红黑树如何保证平衡    

213. ### 问都看过什么书，然后面试官总结一了一下到目前来说的缺点，个人感觉二面面试官一定是个好人😄    

214. ### select poll epoll 各自实现    

215. ### 结构体内存对齐方式    

216. ### mysql了解吗？    

217. ### kmp，ac自动机 算法   

218. ### 项目介绍  	

219. ### 项目中用的Springboot有，没有想到用其他的框架做  	

220. ### 说一下Spring ,Springboot,springmvc的区别  	

221. ### 说一下项目中的技术问题，你是怎么实现的  	

222. ### 项目中HikariCP数据库连接池 （解释）  	

223. ### 了解过其他的连接池吗  	

224. ### docker相关，用docker发布项目的吗  	

225. ### 能用你的话说下docker容器吗和传统的虚拟机有什么区别  	

226. ###  docker是什么样的东西吗  	

227. ### 数据库的delete和truncate区别  	

228. ### 多态的解释  	

229. ### 平时用到过反射吗 说一下  	

230. ### 反射的实现原理  	

231. ### 项目中mysql，redis和mongdb区别？和具体的应用场景？  	

232. ### 道算法题 剑指offer** **Offer 45. 把数组排成最小的数**  	

233. ### 字符串翻转  	

234. ### 算法第一个我真忘了，死想不出来了，面试官感觉我太差，就让我写了下面一题，说写个方法吧。

235. ### 问了一些Java相关的基础问题 

236. ### spring和SpringMVC的大体问题 ，spring基于java的什么实现的？ 