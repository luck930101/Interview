# 1.单例模式

在有些系统中，为了节省内存资源、保证数据内容的一致性，对某些类要求只能创建一个实例，这就是所谓的单例模式。

## 单例模式的定义与特点

单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。



在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。



单例模式有 3 个特点：

1. 单例类只有一个实例对象；

1. 该单例对象必须由单例类自行创建；

1. 单例类对外提供一个访问该单例的全局访问点；

## 单例模式的结构与实现

单例模式是设计模式中最简单的模式之一。通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。



下面来分析其基本结构和实现方法。

### 1. 单例模式的结构

单例模式的主要角色如下。

- 单例类：包含一个实例且能自行创建这个实例的类。

- 访问类：使用单例的类。



其结构如图 1 所示。

![img](https://uploader.shimo.im/f/IxeSAdSuI07JQSl8.png!thumbnail)

图1 单例模式的结构图

### 2. 单例模式的实现

#### 特点：

- 类构造器私有

- 持有自己类型的属性

- 对外提供获取实例的静态方法



1. **懒汉模式** 

线程不安全，延迟初始化，严格意义上不是不是单例模式

Java

**public** **class** **Singleton** {  

​    **private** **static** Singleton instance;  

​    **private** **Singleton** (){}  

  

​    **public** **static** Singleton **getInstance**() {  

​    **if** (instance == **null**) {  

​        instance = **new** Singleton();  

​    }  

​    **return** instance;  

​    }  

}

 

**饿汉模式**

 线程安全，比较常用，但容易产生垃圾，因为一开始就初始化

Java

**public** **class** **Singleton** {  

​    **private** **static** Singleton instance = **new** Singleton();  

​    **private** **Singleton** (){}  

​    **public** **static** Singleton **getInstance**() {  

​      **return** instance;  

​    }  

}

 

**双重锁模式**

 线程安全，延迟初始化。这种方式采用双锁机制，安全且在多线程情况下能保持高性能。

Java

**public** **class** **Singleton** {  

​    **private** **volatile** **static** Singleton singleton;  

​    **private** **Singleton** (){}  

​    **public** **static** Singleton **getSingleton**() {  

​      **if** (singleton == **null**) {  

​          **synchronized** (Singleton.class) {  

​            **if** (singleton == **null**) {  

​                singleton = **new** Singleton();  

​              }  

​            }  

​      }  

​      **return** singleton;  

​    }  

}

 

双重检查模式，进行了两次的判断，第一次是为了避免不要的实例，第二次是为了进行同步，避免多线程问题。由于`singleton=new Singleton()`对象的创建在JVM中可能会进行重排序，在多线程访问下存在风险，使用`volatile`修饰`signleton`实例变量有效，解决该问题。

 

**静态内部类单例模式**

Java

**public** **class** **Singleton** { 

​    **private** **Singleton**(){

​    }

​      **public** **static** Singleton **getInstance**(){  

​        **return** Inner.instance;  

​    }  

​    **private** **static** **class** **Inner** {  

​        **private** **static** **final** Singleton instance = **new** Singleton();  

​    }  

} 

 

只有第一次调用getInstance方法时，虚拟机才加载 Inner 并初始化instance ，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。目前此方式是所有单例模式中最推荐的模式，但具体还是根据项目选择。



 **枚举单例模式**

Java

**public** **enum** Singleton {

​    INSTANCE;

}

 

默认枚举实例的创建是线程安全的，并且在任何情况下都是单例。实际上

- 枚举类隐藏了私有的构造器。

- 枚举类的域 是相应类型的一个实例对象 那么枚举类型日常用例是这样子的：

 

Java

**public** **enum** Singleton  {

​    INSTANCE 

​    //doSomething 该实例支持的行为

​    

​    //可以省略此方法，通过Singleton.INSTANCE进行操作

​    **public** **static** Singleton get **Instance**() {

​        **return** Singleton.INSTANCE;

​    }

}

 

枚举单例模式在《Effective Java》中推荐的单例模式之一。但枚举实例在日常开发是很少使用的，就是很简单以导致可读性较差。

 在以上所有的单例模式中，推荐静态内部类单例模式。主要是非常直观，即保证线程安全又保证唯一性。

 众所周知，单例模式是创建型模式，都会新建一个实例。那么一个重要的问题就是反序列化。当实例被写入到文件到反序列化成实例时，我们需要重写`readResolve`方法，以让实例唯一。

 

Java

**private** Object **readResolve**() **throws** ObjectStreamException{

​        **return** singleton;

}

 



## 单例模式的应用实例

【例1】用懒汉式单例模式模拟产生美国当今总统对象。



分析：在每一届任期内，美国的总统只有一人，所以本实例适合用单例模式实现，图 2 所示是用懒汉式单例实现的结构图。



![img](https://uploader.shimo.im/f/2USYfLPUTa35U3Dw.png!thumbnail)

图2 美国总统生成器的结构图



程序代码如下：

Java

**public** **class** **SingletonLazy**

{

​    **public** **static** **void** **main**(String[] args)

​    {

​        President zt1=President.getInstance();

​        zt1.getName();    //输出总统的名字

​        President zt2=President.getInstance();

​        zt2.getName();    //输出总统的名字

​        **if**(zt1==zt2)

​        {

​           System.out.println("他们是同一人！");

​        }

​        **else**

​        {

​           System.out.println("他们不是同一人！");

​        }

​    }

}

**class** **President**

{

​    **private** **static** **volatile** President instance=**null**;    //保证instance在所有线程中同步

​    //private避免类在外部被实例化

​    **private** **President**()

​    {

​        System.out.println("产生一个总统！");

​    }

​    **public** **static** **synchronized** President **getInstance**()

​    {

​        //在getInstance方法上加同步

​        **if**(instance==**null**)

​        {

​               instance=**new** President();

​        }

​        **else**

​        {

​           System.out.println("已经有一个总统，不能产生新总统！");

​        }

​        **return** instance;

​    }

​    **public** **void** **getName**()

​    {

​        System.out.println("我是美国总统：特朗普。");

​    }  

}



程序运行结果如下：

Plain  Text

产生一个总统！

我是美国总统：特朗普。

已经有一个总统，不能产生新总统！

我是美国总统：特朗普。

他们是同一人！



【例2】用饿汉式单例模式模拟产生猪八戒对象。



分析：同上例类似，猪八戒也只有一个，所以本实例同样适合用单例模式实现。本实例由于要显示猪八戒的图像，所以用到了框架窗体 JFrame 组件，这里的猪八戒类是单例类，可以将其定义成面板 JPanel 的子类，里面包含了标签，用于保存猪八戒的图像，客户窗体可以获得猪八戒对象，并显示它。图 3 所示是用饿汉式单例实现的结构图。



![img](https://uploader.shimo.im/f/DZgaCj8M7OJzhWMW.png!thumbnail)

图3 猪八戒生成器的结构图



程序代码如下：

Java

**import** java.awt.*;

**import** javax.swing.*;

**public** **class** **SingletonEager**

{

​    **public** **static** **void** **main**(String[] args)

​    {

​        JFrame jf=**new** JFrame("饿汉单例模式测试");

​        jf.setLayout(**new** GridLayout(1,2));

​        Container contentPane=jf.getContentPane();

​        Bajie obj1=Bajie.getInstance();

​        contentPane.add(obj1);    

​        Bajie obj2=Bajie.getInstance(); 

​        contentPane.add(obj2);

​        **if**(obj1==obj2)

​        {

​            System.out.println("他们是同一人！");

​        }

​        **else**

​        {

​            System.out.println("他们不是同一人！");

​        }   

​        jf.pack();       

​        jf.setVisible(**true**);

​        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

​    }

}

**class** **Bajie** **extends** **JPanel**

{

​    **private** **static** Bajie instance=**new** Bajie();

​    **private** **Bajie**()

​    { 

​        JLabel l1=**new** JLabel(**new** ImageIcon("src/Bajie.jpg"));

​        **this**.add(l1);   

​    }

​    **public** **static** Bajie **getInstance**()

​    {

​        **return** instance;

​    }

}



程序运行结果如图 4 所示。



![img](https://uploader.shimo.im/f/e6pgSU6F1QJBMnZA.png!thumbnail)

图4 猪八戒生成器的运行结果

## 单例模式的应用场景

前面分析了单例模式的结构与特点，以下是它通常适用的场景的特点。

- 在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。

- 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。

- 当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。



# 2.工厂模式

在现实生活中社会分工越来越细，越来越专业化。各种产品有专门的工厂生产，彻底告别了自给自足的小农经济时代，这大大缩短了产品的生产周期，提高了生产效率。同样，在软件开发中能否做到软件对象的生产和使用相分离呢？能否在满足“开闭原则”的前提下，客户随意增删或改变对软件相关对象的使用呢？这就是本节要讨论的问题。

## 模式的定义与特点

工厂方法（FactoryMethod）模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。



我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”，它不属于 GoF 的 23 种经典设计模式，它的缺点是增加新产品时会违背“开闭原则”。



本节介绍的“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。



工厂方法模式的主要优点有：

- 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；

- 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；



其缺点是：每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。

## 模式的结构与实现

工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成。本节来分析其基本结构和实现方法。

#### 1. 模式的结构

工厂方法模式的主要角色如下。

1. 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。

1. 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。

1. 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。

1. 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。



其结构图如图 1 所示。



![img](https://uploader.shimo.im/f/74rBNg1vhODbMo2W.png!thumbnail)

图1 工厂方法模式的结构图

#### 2. 模式的实现

根据图 1 写出该模式的代码如下：

Java

**package** FactoryMethod;

**public** **class** **AbstractFactoryTest**

{

​    **public** **static** **void** **main**(String[] args)

​    {

​        **try**

​        {

​            Product a;

​            AbstractFactory af;

​            af=(AbstractFactory) ReadXML1.getObject();

​            a=af.newProduct();

​            a.show();

​        }

​        **catch**(Exception e)

​        {

​            System.out.println(e.getMessage());

​        }

​    }

}

//抽象产品：提供了产品的接口

**interface** **Product**

{

​    **public** **void** **show**();

}

//具体产品1：实现抽象产品中的抽象方法

**class** **ConcreteProduct1** **implements** **Product**

{

​    **public** **void** **show**()

​    {

​        System.out.println("具体产品1显示...");

​    }

}

//具体产品2：实现抽象产品中的抽象方法

**class** **ConcreteProduct2** **implements** **Product**

{

​    **public** **void** **show**()

​    {

​        System.out.println("具体产品2显示...");

​    }

}

//抽象工厂：提供了厂品的生成方法

**interface** **AbstractFactory**

{

​    **public** Product **newProduct**();

}

//具体工厂1：实现了厂品的生成方法

**class** **ConcreteFactory1** **implements** **AbstractFactory**

{

​    **public** Product **newProduct**()

​    {

​        System.out.println("具体工厂1生成-->具体产品1...");

​        **return** **new** ConcreteProduct1();

​    }

}

//具体工厂2：实现了厂品的生成方法

**class** **ConcreteFactory2** **implements** **AbstractFactory**

{

​    **public** Product **newProduct**()

​    {

​        System.out.println("具体工厂2生成-->具体产品2...");

​        **return** **new** ConcreteProduct2();

​    }

}

**package** FactoryMethod;

**import** javax.xml.parsers.*;

**import** org.w3c.dom.*;

**import** java.io.*;

**class** **ReadXML1**

{

​    //该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象

​    **public** **static** Object **getObject**()

​    {

​        **try**

​        {

​            //创建文档对象

​            DocumentBuilderFactory dFactory=DocumentBuilderFactory.newInstance();

​            DocumentBuilder builder=dFactory.newDocumentBuilder();

​            Document doc;                           

​            doc=builder.parse(**new** File("src/FactoryMethod/config1.xml"));        

​            //获取包含类名的文本节点

​            NodeList nl=doc.getElementsByTagName("className");

​            Node classNode=nl.item(0).getFirstChild();

​            String cName="FactoryMethod."+classNode.getNodeValue();

​            //System.out.println("新类名："+cName);

​            //通过类名生成实例对象并将其返回

​            Class<?> c=Class.forName(cName);

​              Object obj=c.newInstance();

​            **return** obj;

​         }  

​         **catch**(Exception e)

​         {

​                   e.printStackTrace();

​                   **return** **null**;

​         }

​    }

}



//上述代码使用到的config1.xmll文件

HTML, XML

<?xml version="1.0" encoding="UTF-8"?>

<**config**>

  <**className**>ConcreteFactory1</**className**>

</**config**>



程序运行结果如下：

Plain  Text

具体工厂1生成-->具体产品1...

具体产品1显示...



如果将 XML 配置文件中的 ConcreteFactory1 改为 ConcreteFactory2，则程序运行结果如下：

Plain  Text

具体工厂2生成-->具体产品2...

具体产品2显示...

## 模式的应用实例

【例1】用工厂方法模式设计畜牧场。



分析：有很多种类的畜牧场，如养马场用于养马，养牛场用于养牛，所以该实例用工厂方法模式比较适合。



对养马场和养牛场等具体工厂类，只要定义一个生成动物的方法 newAnimal() 即可。由于要显示马类和牛类等具体产品类的图像，所以它们的构造函数中用到了 JPanel、JLabd 和 ImageIcon 等组件，并定义一个 show() 方法来显示它们。



客户端程序通过对象生成器类 ReadXML2 读取 XML 配置文件中的数据来决定养马还是养牛。其结构图如图 2 所示。



![img](https://uploader.shimo.im/f/EQQRrb2JY92LBNKU.png!thumbnail)

图2 畜牧场结构图



程序代码如下：

Java

**package** FactoryMethod;

**import** java.awt.*;

**import** javax.swing.*;

**public** **class** **AnimalFarmTest**

{

​    **public** **static** **void** **main**(String[] args)

​    {

​        **try**

​        {

​            Animal a;

​            AnimalFarm af;

​            af=(AnimalFarm) ReadXML2.getObject();

​            a=af.newAnimal();

​            a.show();

​        }

​        **catch**(Exception e)

​        {

​            System.out.println(e.getMessage());

​        }

​    }

}

//抽象产品：动物类

**interface** **Animal**

{

​    **public** **void** **show**();

}

//具体产品：马类

**class** **Horse** **implements** **Animal**

{

​    JScrollPane sp;

​    JFrame jf=**new** JFrame("工厂方法模式测试");

​    **public** **Horse**()

​    {

​        Container contentPane=jf.getContentPane();

​        JPanel p1=**new** JPanel();

​        p1.setLayout(**new** GridLayout(1,1));

​        p1.setBorder(BorderFactory.createTitledBorder("动物：马"));

​        sp=**new** JScrollPane(p1);

​        contentPane.add(sp, BorderLayout.CENTER);

​        JLabel l1=**new** JLabel(**new** ImageIcon("src/A_Horse.jpg"));

​        p1.add(l1);       

​        jf.pack();       

​        jf.setVisible(**false**);

​        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    //用户点击窗口关闭 

​    }

​    **public** **void** **show**()

​    {

​        jf.setVisible(**true**);

​    }

}

//具体产品：牛类

**class** **Cattle** **implements** **Animal**

{

​    JScrollPane sp;

​    JFrame jf=**new** JFrame("工厂方法模式测试");

​    **public** **Cattle**()

​    {

​        Container contentPane=jf.getContentPane();

​        JPanel p1=**new** JPanel();

​        p1.setLayout(**new** GridLayout(1,1));

​        p1.setBorder(BorderFactory.createTitledBorder("动物：牛"));

​        sp=**new** JScrollPane(p1);

​        contentPane.add(sp,BorderLayout.CENTER);

​        JLabel l1=**new** JLabel(**new** ImageIcon("src/A_Cattle.jpg"));

​        p1.add(l1);       

​        jf.pack();       

​        jf.setVisible(**false**);

​        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    //用户点击窗口关闭 

​    }

​    **public** **void** **show**()

​    {

​        jf.setVisible(**true**);

​    }

}

//抽象工厂：畜牧场

**interface** **AnimalFarm**

{

​    **public** Animal **newAnimal**();

}

//具体工厂：养马场

**class** **HorseFarm** **implements** **AnimalFarm**

{

​    **public** Animal **newAnimal**()

​    {

​        System.out.println("新马出生！");

​        **return** **new** Horse();

​    }

}

//具体工厂：养牛场

**class** **CattleFarm** **implements** **AnimalFarm**

{

​    **public** Animal **newAnimal**()

​    {

​        System.out.println("新牛出生！");

​        **return** **new** Cattle();

​    }

}



Java

**package** FactoryMethod;

**import** javax.xml.parsers.*;

**import** org.w3c.dom.*;

**import** java.io.*;

**class** **ReadXML2**

{

​    **public** **static** Object **getObject**()

​    {

​        **try**

​        {

​            DocumentBuilderFactory dFactory=DocumentBuilderFactory.newInstance();

​            DocumentBuilder builder=dFactory.newDocumentBuilder();

​            Document doc;                           

​            doc=builder.parse(**new** File("src/FactoryMethod/config2.xml"));

​            NodeList nl=doc.getElementsByTagName("className");

​            Node classNode=nl.item(0).getFirstChild();

​            String cName="FactoryMethod."+classNode.getNodeValue();

​            System.out.println("新类名："+cName);

​            Class<?> c=Class.forName(cName);

​              Object obj=c.newInstance();

​            **return** obj;

​        }  

​        **catch**(Exception e)

​        {

​               e.printStackTrace();

​               **return** **null**;

​        }

​    }

}





程序的运行结果如图 3 所示。



![img](https://uploader.shimo.im/f/DcAUDKdSn4Yodyhs.png!thumbnail)

图3 畜牧场养殖的运行结果

## 模式的应用场景

工厂方法模式通常适用于以下场景。

- 客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。

- 创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。

- 客户不关心创建产品的细节，只关心产品的品牌。

## 模式的扩展

当需要生成的产品不多且不会增加，一个具体工厂类就可以完成任务时，可删除抽象工厂类。这时工厂方法模式将退化到简单工厂模式，其结构图如图 4 所示。



![img](https://uploader.shimo.im/f/6n3siGxflRPvaYwB.png!thumbnail)

图4 简单工厂模式的结构图

# 3.抽象工厂模式

前面介绍的工厂模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。



同种类称为同等级，也就是说：工厂模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。



本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，图 1 所示的是海尔工厂和 TCL 工厂所生产的电视机与空调对应的关系图。



![img](https://uploader.shimo.im/f/kWFxqIhxG35EaUGx.png!thumbnail)

图1 电器工厂的产品等级与产品族

## 模式的定义与特点

抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。



抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。



使用抽象工厂模式一般要满足以下条件。

- 系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。

- 系统一次只可能消费其中某一族产品，即同族的产品一起使用。



抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。

- 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。

- 当增加一个新的产品族时不需要修改原代码，满足开闭原则。



其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。

## 模式的结构与实现

抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。现在我们来分析其基本结构和实现方法。

#### 1. 模式的结构

抽象工厂模式的主要角色如下。

1. 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。

1. 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。

1. 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。

1. 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。



抽象工厂模式的结构图如图 2 所示。



![img](https://uploader.shimo.im/f/42mQPMy90M3WH1fm.png!thumbnail)

图2 抽象工厂模式的结构图

#### 2. 模式的实现

从图 2 可以看出抽象工厂模式的结构同工厂方法模式的结构相似，不同的是其产品的种类不止一个，所以创建产品的方法也不止一个。下面给出抽象工厂和具体工厂的代码。



(1) 抽象工厂：提供了产品的生成方法。

Java

**interface** **AbstractFactory**

{

​    **public** Product1 **newProduct1**();

​    **public** Product2 **newProduct2**();

}



(2) 具体工厂：实现了产品的生成方法。

Java

**class** **ConcreteFactory1** **implements** **AbstractFactory**

{

​    **public** Product1 **newProduct1**()

​    {

​        System.out.println("具体工厂 1 生成-->具体产品 11...");

​        **return** **new** ConcreteProduct11();

​    }

​    **public** Product2 **newProduct2**()

​    {

​        System.out.println("具体工厂 1 生成-->具体产品 21...");

​        **return** **new** ConcreteProduct21();

​    }

}

## 模式的应用实例

【例1】用抽象工厂模式设计农场类。



分析：农场中除了像畜牧场一样可以养动物，还可以培养植物，如养马、养牛、种菜、种水果等，所以本实例比前面介绍的畜牧场类复杂，必须用抽象工厂模式来实现。



本例用抽象工厂模式来设计两个农场，一个是韶关农场用于养牛和种菜，一个是上饶农场用于养马和种水果，可以在以上两个农场中定义一个生成动物的方法 newAnimal() 和一个培养植物的方法 newPlant()。



对马类、牛类、蔬菜类和水果类等具体产品类，由于要显示它们的图像，所以它们的构造函数中用到了 JPanel、JLabel 和 ImageIcon 等组件，并定义一个 show() 方法来显示它们。



客户端程序通过对象生成器类 ReadXML 读取 XML 配置文件中的数据来决定养什么动物和培养什么植物。其结构图如图 3 所示。



![img](https://uploader.shimo.im/f/eNthRZI7WDE1ZWnE.png!thumbnail)

图3 农场类的结构图



程序代码如下：

Java

**package** AbstractFactory;

**import** java.awt.*;

**import** javax.swing.*;

**public** **class** **FarmTest**

{

​    **public** **static** **void** **main**(String[] args)

​    {

​        **try**

​        {          

​            Farm f;

​            Animal a;

​            Plant p;

​            f=(Farm) ReadXML.getObject();

​            a=f.newAnimal();

​            p=f.newPlant();

​            a.show();

​            p.show();

​        }

​        **catch**(Exception e)

​        {

​            System.out.println(e.getMessage());

​        }

​    }

}

//抽象产品：动物类

**interface** **Animal**

{

​    **public** **void** **show**();

}

//具体产品：马类

**class** **Horse** **implements** **Animal**

{

​    JScrollPane sp;

​    JFrame jf=**new** JFrame("抽象工厂模式测试");

​    **public** **Horse**()

​    {

​        Container contentPane=jf.getContentPane();

​        JPanel p1=**new** JPanel();

​        p1.setLayout(**new** GridLayout(1,1));

​        p1.setBorder(BorderFactory.createTitledBorder("动物：马"));

​        sp=**new** JScrollPane(p1);

​        contentPane.add(sp, BorderLayout.CENTER);

​        JLabel l1=**new** JLabel(**new** ImageIcon("src/A_Horse.jpg"));

​        p1.add(l1);       

​        jf.pack();       

​        jf.setVisible(**false**);

​        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//用户点击窗口关闭 

​    }

​    **public** **void** **show**()

​    {

​        jf.setVisible(**true**);

​    }

}

//具体产品：牛类

**class** **Cattle** **implements** **Animal**

{

​    JScrollPane sp;

​    JFrame jf=**new** JFrame("抽象工厂模式测试");

​    **public** **Cattle**() {

​        Container contentPane=jf.getContentPane();

​        JPanel p1=**new** JPanel();

​        p1.setLayout(**new** GridLayout(1,1));

​        p1.setBorder(BorderFactory.createTitledBorder("动物：牛"));

​        sp=**new** JScrollPane(p1);

​        contentPane.add(sp, BorderLayout.CENTER);

​        JLabel l1=**new** JLabel(**new** ImageIcon("src/A_Cattle.jpg"));

​        p1.add(l1);       

​        jf.pack();       

​        jf.setVisible(**false**);

​        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//用户点击窗口关闭 

​    }

​    **public** **void** **show**()

​    {

​        jf.setVisible(**true**);

​    }

}

//抽象产品：植物类

**interface** **Plant**

{

​    **public** **void** **show**();

}

//具体产品：水果类

**class** **Fruitage** **implements** **Plant**

{

​    JScrollPane sp;

​    JFrame jf=**new** JFrame("抽象工厂模式测试");

​    **public** **Fruitage**()

​    {

​        Container contentPane=jf.getContentPane();

​        JPanel p1=**new** JPanel();

​        p1.setLayout(**new** GridLayout(1,1));

​        p1.setBorder(BorderFactory.createTitledBorder("植物：水果"));

​        sp=**new** JScrollPane(p1);

​        contentPane.add(sp, BorderLayout.CENTER);

​        JLabel l1=**new** JLabel(**new** ImageIcon("src/P_Fruitage.jpg"));

​        p1.add(l1);       

​        jf.pack();       

​        jf.setVisible(**false**);

​        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//用户点击窗口关闭 

​    }

​    **public** **void** **show**()

​    {

​        jf.setVisible(**true**);

​    }

}

//具体产品：蔬菜类

**class** **Vegetables** **implements** **Plant**

{

​    JScrollPane sp;

​    JFrame jf=**new** JFrame("抽象工厂模式测试");

​    **public** **Vegetables**()

​    {

​        Container contentPane=jf.getContentPane();

​        JPanel p1=**new** JPanel();

​        p1.setLayout(**new** GridLayout(1,1));

​        p1.setBorder(BorderFactory.createTitledBorder("植物：蔬菜"));

​        sp=**new** JScrollPane(p1);

​        contentPane.add(sp, BorderLayout.CENTER);

​        JLabel l1=**new** JLabel(**new** ImageIcon("src/P_Vegetables.jpg"));

​        p1.add(l1);       

​        jf.pack();       

​        jf.setVisible(**false**);

​        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//用户点击窗口关闭 

​    }

​    **public** **void** **show**()

​    {

​        jf.setVisible(**true**);

​    }

}

//抽象工厂：农场类

**interface** **Farm**

{

​    **public** Animal **newAnimal**();

​    **public** Plant **newPlant**();

}

//具体工厂：韶关农场类

**class** **SGfarm** **implements** **Farm**

{

​    **public** Animal **newAnimal**()

​    {

​        System.out.println("新牛出生！");

​        **return** **new** Cattle();

​    }

​    **public** Plant **newPlant**()

​    {

​        System.out.println("蔬菜长成！");

​        **return** **new** Vegetables();

​    }

}

//具体工厂：上饶农场类

**class** **SRfarm** **implements** **Farm**

{

​    **public** Animal **newAnimal**()

​    {

​        System.out.println("新马出生！");

​        **return** **new** Horse();

​    }

​    **public** Plant **newPlant**()

​    {

​        System.out.println("水果长成！");

​        **return** **new** Fruitage();

​    }

}



Java

**package** AbstractFactory;

**import** javax.xml.parsers.*;

**import** org.w3c.dom.*;

**import** java.io.*;

**class** **ReadXML**

{

​    **public** **static** Object **getObject**()

​    {

​        **try**

​        {

​            DocumentBuilderFactory dFactory=DocumentBuilderFactory.newInstance();

​            DocumentBuilder builder=dFactory.newDocumentBuilder();

​            Document doc;                           

​            doc=builder.parse(**new** File("src/AbstractFactory/config.xml"));

​            NodeList nl=doc.getElementsByTagName("className");

​            Node classNode=nl.item(0).getFirstChild();

​            String cName="AbstractFactory."+classNode.getNodeValue();

​            System.out.println("新类名："+cName);

​            Class<?> c=Class.forName(cName);

​              Object obj=c.newInstance();

​            **return** obj;

​        }  

​        **catch**(Exception e)

​        {

​               e.printStackTrace();

​               **return** **null**;

​        }

​    }

}



HTML, XML

<?xml version="1.0" encoding="UTF-8"?>

<**config**>

  <**className**>SGfarm</**className**>

</**config**>



程序运行结果如图 4 所示。



![img](https://uploader.shimo.im/f/QzRwTSlNKFlLGgCt.png!thumbnail)

图4 农场养殖的运行结果

## 模式的应用场景

抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件。如 java 的 AWT 中的 Button 和 Text 等构件在 Windows 和 UNIX 中的本地实现是不同的。



抽象工厂模式通常适用于以下场景：

1. 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。

1. 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。

1. 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。

## 模式的扩展

抽象工厂模式的扩展有一定的“开闭原则”倾斜性：

1. 当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。

1. 当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。



另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。



# 4.代理模式

在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。



在软件设计中，使用代理模式的例子也很多，例如，要访问的远程对象比较大（如视频或大图像等），其下载要花很多时间。还有因为安全原因需要屏蔽客户端直接访问真实对象，如某单位的内部数据库等。

## 代理模式的定义与特点

代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。



代理模式的主要优点有：

- 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；

- 代理对象可以扩展目标对象的功能；

- 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；



其主要缺点是：

- 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；

- 增加了系统的复杂度；

## 代理模式的结构与实现

代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。

#### 1. 模式的结构

代理模式的主要角色如下。

1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。

1. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。

1. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。



其结构图如图 1 所示。



![img](https://uploader.shimo.im/f/CPGwlKANf1aMyJq4.png!thumbnail)

图1 代理模式的结构图

#### 2. 模式的实现

代理模式的实现代码如下：

Java

**package** proxy;

**public** **class** **ProxyTest**

{

​    **public** **static** **void** **main**(String[] args)

​    {

​        Proxy proxy=**new** Proxy();

​        proxy.Request();

​    }

}

//抽象主题

**interface** **Subject**

{

​    **void** **Request**();

}

//真实主题

**class** **RealSubject** **implements** **Subject**

{

​    **public** **void** **Request**()

​    {

​        System.out.println("访问真实主题方法...");

​    }

}

//代理

**class** **Proxy** **implements** **Subject**

{

​    **private** RealSubject realSubject;

​    **public** **void** **Request**()

​    {

​        **if** (realSubject==**null**)

​        {

​            realSubject=**new** RealSubject();

​        }

​        preRequest();

​        realSubject.Request();

​        postRequest();

​    }

​    **public** **void** **preRequest**()

​    {

​        System.out.println("访问真实主题之前的预处理。");

​    }

​    **public** **void** **postRequest**()

​    {

​        System.out.println("访问真实主题之后的后续处理。");

​    }

}



程序运行的结果如下：

Plain  Text

访问真实主题之前的预处理。

访问真实主题方法...

访问真实主题之后的后续处理。

## 代理模式的应用实例

【例1】韶关“天街e角”公司是一家婺源特产公司的代理公司，用代理模式实现。



分析：本实例中的“婺源特产公司”经营许多婺源特产，它是真实主题，提供了显示特产的 display() 方法，可以用窗体程序实现。而韶关“天街e角”公司是婺源特产公司特产的代理，通过调用婺源特产公司的 display() 方法显示代理产品，当然它可以增加一些额外的处理，如包裝或加价等。客户可通过“天街e角”代理公司间接访问“婺源特产公司”的产品，图 2 所示是公司的结构图。



![img](https://uploader.shimo.im/f/zVSQo7Tze5ebLjrF.png!thumbnail)

图2 韶关“天街e角”公司的结构图



程序代码如下：

Java

**package** proxy;

**import** java.awt.*;

**import** javax.swing.*;

**public** **class** **WySpecialtyProxy**

{

​    **public** **static** **void** **main**(String[] args)

​    {

​        SgProxy proxy=**new** SgProxy();

​        proxy.display();

​    }

}

//抽象主题：特产

**interface** **Specialty**

{

​    **void** **display**();

}

//真实主题：婺源特产

**class** **WySpecialty** **extends** **JFrame** **implements** **Specialty**

{

​    **private** **static** **final** **long** serialVersionUID=1L;

​    **public** **WySpecialty**()

​    {

​        **super**("韶关代理婺源特产测试");

​        **this**.setLayout(**new** GridLayout(1,1));

​        JLabel l1=**new** JLabel(**new** ImageIcon("src/proxy/WuyuanSpecialty.jpg"));

​        **this**.add(l1);   

​        **this**.pack();       

​        **this**.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);      

​    }

​    **public** **void** **display**()

​    {

​        **this**.setVisible(**true**);

​    }

}

//代理：韶关代理

**class** **SgProxy** **implements** **Specialty**

{

​    **private** WySpecialty realSubject=**new** WySpecialty();

​    **public** **void** **display**()

​    {

​        preRequest();

​        realSubject.display();

​        postRequest();

​    }

​    **public** **void** **preRequest**()

​    {

​          System.out.println("韶关代理婺源特产开始。");

​    }

​    **public** **void** **postRequest**()

​    {

​          System.out.println("韶关代理婺源特产结束。");

​    }

}



程序运行结果如图 3 所示。



![img](https://uploader.shimo.im/f/LKKs7m155mRRITB5.png!thumbnail)

图3 韶关“天街e角”公司的代理产品

## 代理模式的应用场景

前面分析了代理模式的结构与特点，现在来分析以下的应用场景。

- 远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。

- 虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。

- 安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。

- 智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。

- 延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate中就存在属性的延迟加载和关联表的延时加载。

## 代理模式的扩展

在前面介绍的代理模式中，代理类中包含了对真实主题的引用，这种方式存在两个缺点。

1. 真实主题与代理主题一一对应，增加真实主题也要增加代理。

1. 设计代理以前真实主题必须事先存在，不太灵活。采用动态代理模式可以解决以上问题，如 SpringAOP，其结构图如图 4 所示。



![img](https://uploader.shimo.im/f/HhBlOUK1x7SbbqK1.png!thumbnail)

图4 动态代理模式的结构图





# 5.适配器模式

在现实生活中，经常出现两个对象因接口不兼容而不能在一起工作的实例，这时需要第三者进行适配。例如，讲中文的人同讲英文的人对话时需要一个翻译，用直流电的笔记本电脑接交流电源时需要一个电源适配器，用计算机访问照相机的 SD 内存卡时需要一个读卡器等。



在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。

## 模式的定义与特点

适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。



该模式的主要优点如下。

- 客户端通过适配器可以透明地调用目标接口。

- 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。

- 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。



其缺点是：对类适配器来说，更换适配器的实现过程比较复杂。

## 模式的结构与实现

类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。



对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。现在来介绍它们的基本结构。

#### 1. 模式的结构

适配器模式（Adapter）包含以下主要角色。

1. 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。

1. 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。

1. 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。



类适配器模式的结构图如图 1 所示。



![img](https://uploader.shimo.im/f/2RwjFb5StLkuLouP.png!thumbnail)

图1 类适配器模式的结构图



对象适配器模式的结构图如图 2 所示。



![img](https://uploader.shimo.im/f/TljvJl7eFaJDhW19.png!thumbnail)

图2 对象适配器模式的结构图

#### 2. 模式的实现

(1) 类适配器模式的代码如下。

Java

**package** adapter;

//目标接口

**interface** **Target**

{

​    **public** **void** **request**();

}

//适配者接口

**class** **Adaptee**

{

​    **public** **void** **specificRequest**()

​    {       

​        System.out.println("适配者中的业务代码被调用！");

​    }

}

//类适配器类

**class** **ClassAdapter** **extends** **Adaptee** **implements** **Target**

{

​    **public** **void** **request**()

​    {

​        specificRequest();

​    }

}

//客户端代码

**public** **class** **ClassAdapterTest**

{

​    **public** **static** **void** **main**(String[] args)

​    {

​        System.out.println("类适配器模式测试：");

​        Target target = **new** ClassAdapter();

​        target.request();

​    }

}



程序的运行结果如下：

Plain  Text

类适配器模式测试：

适配者中的业务代码被调用！



(2)对象适配器模式的代码如下。

Java

**package** adapter;

//对象适配器类

**class** **ObjectAdapter** **implements** **Target**

{

​    **private** Adaptee adaptee;

​    **public** **ObjectAdapter**(Adaptee adaptee)

​    {

​        **this**.adaptee=adaptee;

​    }

​    **public** **void** **request**()

​    {

​        adaptee.specificRequest();

​    }

}

//客户端代码

**public** **class** **ObjectAdapterTest**

{

​    **public** **static** **void** **main**(String[] args)

​    {

​        System.out.println("对象适配器模式测试：");

​        Adaptee adaptee = **new** Adaptee();

​        Target target = **new** ObjectAdapter(adaptee);

​        target.request();

​    }

}



说明：对象适配器模式中的“目标接口”和“适配者类”的代码同类适配器模式一样，只要修改适配器类和客户端的代码即可。



程序的运行结果如下：

Plain  Text

对象适配器模式测试：

适配者中的业务代码被调用！

## 模式的应用实例

【例1】用适配器模式（Adapter）模拟新能源汽车的发动机。



分析：新能源汽车的发动机有电能发动机（Electric Motor）和光能发动机（Optical Motor）等，各种发动机的驱动方法不同，例如，电能发动机的驱动方法 electricDrive() 是用电能驱动，而光能发动机的驱动方法 opticalDrive() 是用光能驱动，它们是适配器模式中被访问的适配者。



客户端希望用统一的发动机驱动方法 drive() 访问这两种发动机，所以必须定义一个统一的目标接口 Motor，然后再定义电能适配器（Electric Adapter）和光能适配器（Optical Adapter）去适配这两种发动机。



我们把客户端想访问的新能源发动机的适配器的名称放在 XML 配置文件中，客户端可以通过对象生成器类 ReadXML 去读取。这样，客户端就可以通过 Motor 接口随便使用任意一种新能源发动机去驱动汽车，图 3 所示是其结构图。



![img](https://uploader.shimo.im/f/nEgB7fTzDR7Uo64W.png!thumbnail)

图3 发动机适配器的结构图



程序代码如下：

Java

**package** adapter;

//目标：发动机

**interface** **Motor**

{

​    **public** **void** **drive**();

}

//适配者1：电能发动机

**class** **ElectricMotor**

{

​    **public** **void** **electricDrive**()

​    {

​        System.out.println("电能发动机驱动汽车！");

​    }

}

//适配者2：光能发动机

**class** **OpticalMotor**

{

​    **public** **void** **opticalDrive**()

​    {

​        System.out.println("光能发动机驱动汽车！");

​    }

}

//电能适配器

**class** **ElectricAdapter** **implements** **Motor**

{

​    **private** ElectricMotor emotor;

​    **public** **ElectricAdapter**()

​    {

​        emotor=**new** ElectricMotor();

​    }

​    **public** **void** **drive**()

​    {

​        emotor.electricDrive();

​    }

}

//光能适配器

**class** **OpticalAdapter** **implements** **Motor**

{

​    **private** OpticalMotor omotor;

​    **public** **OpticalAdapter**()

​    {

​        omotor=**new** OpticalMotor();

​    }

​    **public** **void** **drive**()

​    {

​        omotor.opticalDrive();

​    }

}

//客户端代码

**public** **class** **MotorAdapterTest**

{

​    **public** **static** **void** **main**(String[] args)

​    {

​        System.out.println("适配器模式测试：");

​        Motor motor=(Motor)ReadXML.getObject();

​        motor.drive();

​    }

}



Java

**package** adapter;

**import** javax.xml.parsers.*;

**import** org.w3c.dom.*;

**import** java.io.*;

**class** **ReadXML**

{

​    **public** **static** Object **getObject**()

​    {

​        **try**

​        {

​            DocumentBuilderFactory dFactory=DocumentBuilderFactory.newInstance();

​            DocumentBuilder builder=dFactory.newDocumentBuilder();

​            Document doc;                           

​            doc=builder.parse(**new** File("src/adapter/config.xml"));

​            NodeList nl=doc.getElementsByTagName("className");

​            Node classNode=nl.item(0).getFirstChild();

​            String cName="adapter."+classNode.getNodeValue();

​            Class<?> c=Class.forName(cName);

​              Object obj=c.newInstance();

​            **return** obj;

​         }  

​         **catch**(Exception e)

​         {

​                   e.printStackTrace();

​                   **return** **null**;

​         }

​    }

}



HTML, XML

<?xml version="1.0" encoding="UTF-8"?>

<**config**>

  <**className**>ElectricAdapter</**className**>

</**config**>





程序的运行结果如下：

Plain  Text

适配器模式测试：

电能发动机驱动汽车！



注意：如果将配置文件中的 ElectricAdapter 改为 OpticalAdapter，则运行结果如下：

Plain  Text

适配器模式测试：

光能发动机驱动汽车！

## 模式的应用场景

适配器模式（Adapter）通常适用于以下场景。

- 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。

- 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。

## 模式的扩展

适配器模式（Adapter）可扩展为双向适配器模式，双向适配器类既可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口，其结构图如图 4 所示。



![img](https://uploader.shimo.im/f/LseJbl1KI0Etk8bn.png!thumbnail)

图4 双向适配器模式的结构图



程序代码如下：

Java

**package** adapter;

//目标接口

**interface** **TwoWayTarget**

{

​    **public** **void** **request**();

}

//适配者接口

**interface** **TwoWayAdaptee**

{

​    **public** **void** **specificRequest**();

}

//目标实现

**class** **TargetRealize** **implements** **TwoWayTarget**

{

​    **public** **void** **request**()

​    {       

​        System.out.println("目标代码被调用！");

​    }

}

//适配者实现

**class** **AdapteeRealize** **implements** **TwoWayAdaptee**

{

​    **public** **void** **specificRequest**()

​    {       

​        System.out.println("适配者代码被调用！");

​    }

}

//双向适配器

**class** **TwoWayAdapter**  **implements** **TwoWayTarget**,**TwoWayAdaptee**

{

​    **private** TwoWayTarget target;

​    **private** TwoWayAdaptee adaptee;

​    **public** **TwoWayAdapter**(TwoWayTarget target)

​    {

​        **this**.target=target;

​    }

​    **public** **TwoWayAdapter**(TwoWayAdaptee adaptee)

​    {

​        **this**.adaptee=adaptee;

​    }

​    **public** **void** **request**()

​    {

​        adaptee.specificRequest();

​    }

​    **public** **void** **specificRequest**()

​    {       

​        target.request();

​    }

}

//客户端代码

**public** **class** **TwoWayAdapterTest**

{

​    **public** **static** **void** **main**(String[] args)

​    {

​        System.out.println("目标通过双向适配器访问适配者：");

​        TwoWayAdaptee adaptee=**new** AdapteeRealize();

​        TwoWayTarget target=**new** TwoWayAdapter(adaptee);

​        target.request();

​        System.out.println("-------------------");

​        System.out.println("适配者通过双向适配器访问目标：");

​        target=**new** TargetRealize();

​        adaptee=**new** TwoWayAdapter(target);

​        adaptee.specificRequest();

​    }

}



程序的运行结果如下：

Plain  Text

目标通过双向适配器访问适配者：

适配者代码被调用！

\-------------------

适配者通过双向适配器访问目标：

目标代码被调用！



# 6.建造者模式（Builder模式）

在软件开发过程中有时需要创建一个复杂的对象，这个复杂对象通常由多个子部件按一定的步骤组合而成。例如，计算机是由 OPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等部件组装而成的，采购员不可能自己去组装计算机，而是将计算机的配置要求告诉计算机销售公司，计算机销售公司安排技术人员去组装计算机，然后再交给要买计算机的采购员。



生活中这样的例子很多，如游戏中的不同角色，其性别、个性、能力、脸型、体型、服装、发型等特性都有所差异；还有汽车中的方向盘、发动机、车架、轮胎等部件也多种多样；每封电子邮件的发件人、收件人、主题、内容、附件等内容也各不相同。



以上所有这些产品都是由多个部件构成的，各个部件可以灵活选择，但其创建步骤都大同小异。这类产品的创建无法用前面介绍的工厂模式描述，只有建造者模式可以很好地描述该类产品的创建。

## 模式的定义与特点

建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。



该模式的主要优点如下：

1. 各个具体的建造者相互独立，有利于系统的扩展。

1. 客户端不必知道产品内部组成的细节，便于控制细节风险。



其缺点如下：

1. 产品的组成部分必须相同，这限制了其使用范围。

1. 如果产品的内部变化复杂，该模式会增加很多的建造者类。



建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂模式更注重零部件的创建过程，但两者可以结合使用。

## 模式的结构与实现

建造者（Builder）模式由产品、抽象建造者、具体建造者、指挥者等 4 个要素构成，现在我们来分析其基本结构和实现方法。

#### 1. 模式的结构

建造者（Builder）模式的主要角色如下。

1. 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个滅部件。

1. 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。

1. 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。

1. 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。



其结构图如图 1 所示。



![img](https://uploader.shimo.im/f/XJPTo7hOjtazrcAH.png!thumbnail)

图1 建造者模式的结构图

#### 2. 模式的实现

图 1 给出了建造者（Builder）模式的主要结构，其相关类的代码如下。



(1) 产品角色：包含多个组成部件的复杂对象。

Java

**class** **Product**

{

​    **private** String partA;

​    **private** String partB;

​    **private** String partC;

​    **public** **void** **setPartA**(String partA)

​    {

​        **this**.partA=partA;

​    }

​    **public** **void** **setPartB**(String partB)

​    {

​        **this**.partB=partB;

​    }

​    **public** **void** **setPartC**(String partC)

​    {

​        **this**.partC=partC;

​    }

​    **public** **void** **show**()

​    {

​        //显示产品的特性

​    }

}



(2) 抽象建造者：包含创建产品各个子部件的抽象方法。

Java

**abstract** **class** **Builder**

{

​    //创建产品对象

​    **protected** Product product=**new** Product();

​    **public** **abstract** **void** **buildPartA**();

​    **public** **abstract** **void** **buildPartB**();

​    **public** **abstract** **void** **buildPartC**();

​    //返回产品对象

​    **public** Product **getResult**()

​    {

​        **return** product;

​    }

}



(3) 具体建造者：实现了抽象建造者接口。

Java

**public** **class** **ConcreteBuilder** **extends** **Builder**

{

​    **public** **void** **buildPartA**()

​    {

​        product.setPartA("建造 PartA");

​    }

​    **public** **void** **buildPartB**()

​    {

​        product.setPartA("建造 PartB");

​    }

​    **public** **void** **buildPartC**()

​    {

​        product.setPartA("建造 PartC");

​    }

}



(4) 指挥者：调用建造者中的方法完成复杂对象的创建。

Java

**class** **Director**

{

​    **private** Builder builder;

​    **public** **Director**(Builder builder)

​    {

​        **this**.builder=builder;

​    }

​    //产品构建与组装方法

​    **public** Product **construct**()

​    {

​        builder.buildPartA();

​        builder.buildPartB();

​        builder.buildPartC();

​        **return** builder.getResult();

​    }

}



(5) 客户类。

Java

**public** **class** **Client**

{

​    **public** **static** **void** **main**(String[] args)

​    {

​        Builder builder=**new** ConcreteBuilder();

​        Director director=**new** Director(builder);

​        Product product=director.construct();

​        product.show();

​    }

}

## 模式的应用实例

【例1】用建造者（Builder）模式描述客厅装修。



分析：客厅装修是一个复杂的过程，它包含墙体的装修、电视机的选择、沙发的购买与布局等。客户把装修要求告诉项目经理，项目经理指挥装修工人一步步装修，最后完成整个客厅的装修与布局，所以本实例用建造者模式实现比较适合。



这里客厅是产品，包括墙、电视和沙发等组成部分。具体装修工人是具体建造者，他们负责装修与墙、电视和沙发的布局。项目经理是指挥者，他负责指挥装修工人进行装修。



另外，客厅类中提供了 show() 方法，可以将装修效果图显示出来（点此下载装修效果图的图片）。客户端程序通过对象生成器类 ReadXML 读取 XML 配置文件中的装修方案数据（点此下载 XML 文件），调用项目经理进行装修。其类图如图 2 所示。



![img](https://uploader.shimo.im/f/EYKJCA0jqVxQKIXd.png!thumbnail)

图2 客厅装修的结构图



程序代码如下：

Java

**package** Builder;

**import** java.awt.*;

**import** javax.swing.*;

**public** **class** **ParlourDecorator**

{

​    **public** **static** **void** **main**(String[] args)

​    {

​        **try**

​        {

​            Decorator d;

​            d=(Decorator) ReadXML.getObject();

​            ProjectManager m=**new** ProjectManager(d);       

​            Parlour p=m.decorate();

​            p.show();

​        }

​        **catch**(Exception e)

​        {

​            System.out.println(e.getMessage());

​        }

​    }

}

//产品：客厅

**class** **Parlour**

{

​    **private** String wall;    //墙

​    **private** String TV;    //电视

​    **private** String sofa;    //沙发  

​    **public** **void** **setWall**(String wall)

​    {

​        **this**.wall=wall;

​    }

​    **public** **void** **setTV**(String TV)

​    {

​        **this**.TV=TV;

​    }

​    **public** **void** **setSofa**(String sofa)

​    {

​        **this**.sofa=sofa;

​    }   

​    **public** **void** **show**()

​    {

​        JFrame jf=**new** JFrame("建造者模式测试");

​        Container contentPane=jf.getContentPane();

​        JPanel p=**new** JPanel();   

​        JScrollPane sp=**new** JScrollPane(p);  

​        String parlour=wall+TV+sofa;

​        JLabel l=**new** JLabel(**new** ImageIcon("src/"+parlour+".jpg"));

​        p.setLayout(**new** GridLayout(1,1));

​        p.setBorder(BorderFactory.createTitledBorder("客厅"));

​        p.add(l);

​        contentPane.add(sp,BorderLayout.CENTER);       

​        jf.pack();  

​        jf.setVisible(**true**);

​        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

​    }   

}

//抽象建造者：装修工人

**abstract** **class** **Decorator**

{

​    //创建产品对象

​    **protected**  Parlour product=**new** Parlour();

​    **public**  **abstract** **void** **buildWall**();

​    **public**  **abstract** **void** **buildTV**();

​    **public**  **abstract** **void** **buildSofa**();

​    //返回产品对象

​    **public**  Parlour **getResult**()

​    {

​        **return**  product;

​    }

}

//具体建造者：具体装修工人1

**class** **ConcreteDecorator1**  **extends** **Decorator**

{

​    **public** **void** **buildWall**()

​    {

​        product.setWall("w1");

​    }

​    **public** **void** **buildTV**()

​    {

​        product.setTV("TV1");

​    }

​    **public** **void** **buildSofa**()

​    {

​        product.setSofa("sf1");

​    }

}

//具体建造者：具体装修工人2

**class** **ConcreteDecorator2** **extends** **Decorator**

{

​    **public** **void** **buildWall**()

​    {

​        product.setWall("w2");

​      }

​      **public** **void** **buildTV**()

​      {

​          product.setTV("TV2");

​      }

​      **public** **void** **buildSofa**()

​      {

​          product.setSofa("sf2");

​      }

}

//指挥者：项目经理

**class** **ProjectManager**

{

​    **private** Decorator builder;

​    **public** **ProjectManager**(Decorator builder)

​    {

​          **this**.builder=builder;

​    }

​    //产品构建与组装方法

​    **public** Parlour **decorate**()

​    {

​          builder.buildWall();

​        builder.buildTV();

​        builder.buildSofa();

​        **return** builder.getResult();

​    }

}



Java

**package** Builder;

**import** javax.xml.parsers.*;

**import** org.w3c.dom.*;

**import** java.io.*;

**class** **ReadXML**

{

​    **public** **static** Object **getObject**()

​    {

​        **try**

​        {

​            DocumentBuilderFactory dFactory=DocumentBuilderFactory.newInstance();

​            DocumentBuilder builder=dFactory.newDocumentBuilder();

​            Document doc;                           

​            doc=builder.parse(**new** File("src/Builder/config.xml"));

​            NodeList nl=doc.getElementsByTagName("className");

​            Node classNode=nl.item(0).getFirstChild();

​            String cName="Builder."+classNode.getNodeValue();

​            System.out.println("新类名："+cName);

​            Class<?> c=Class.forName(cName);

​              Object obj=c.newInstance();

​            **return** obj;

​         }  

​         **catch**(Exception e)

​         {

​                   e.printStackTrace();

​                   **return** **null**;

​         }

​    }

}





程序运行结果如图 3 所示。



![img](https://uploader.shimo.im/f/JbFgwAoM6GRlMVxD.png!thumbnail)

图3 客厅装修的运行结果

## 模式的应用场景

建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。

- 创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。

- 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。

## 模式的扩展

建造者（Builder）模式在应用过程中可以根据需要改变，如果创建的产品种类只有一种，只需要一个具体建造者，这时可以省略掉抽象建造者，甚至可以省略掉指挥者角色。



# 7.策略模式

在现实生活中常常遇到实现某种目标存在多种策略可供选择的情况，例如，出行旅游可以乘坐飞机、乘坐火车、骑自行车或自己开私家车等，超市促销可以釆用打折、送商品、送积分等方法。



在软件开发中也常常遇到类似的情况，当实现某一个功能存在多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能，如数据排序策略有冒泡排序、选择排序、插入排序、二叉树排序等。



如果使用多重条件转移语句实现（即硬编码），不但使条件语句变得很复杂，而且增加、删除或更换算法要修改原代码，不易维护，违背开闭原则。如果采用策略模式就能很好解决该问题。

## 策略模式的定义与特点

策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。



策略模式的主要优点如下。

1. 多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。

1. 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。

1. 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。

1. 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。

1. 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。



其主要缺点如下。

1. 客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。

1. 策略模式造成很多的策略类。

## 策略模式的结构与实现

策略模式是准备一组算法，并将这组算法封装到一系列的策略类里面，作为一个抽象策略类的子类。策略模式的重心不是如何实现算法，而是如何组织这些算法，从而让程序结构更加灵活，具有更好的维护性和扩展性，现在我们来分析其基本结构和实现方法。

#### 1. 模式的结构

策略模式的主要角色如下。

1. 抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。

1. 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。

1. 环境（Context）类：持有一个策略类的引用，最终给客户端调用。



其结构图如图 1 所示。



![img](https://uploader.shimo.im/f/F92LugqNHlM2Bgdc.png!thumbnail)

图1 策略模式的结构图

#### 2. 模式的实现

策略模式的实现代码如下：

Java

**package** strategy;

**public** **class** **StrategyPattern**

{

​    **public** **static** **void** **main**(String[] args)

​    {

​        Context c=**new** Context();

​        Strategy s=**new** ConcreteStrategyA();

​        c.setStrategy(s);

​        c.strategyMethod();

​        System.out.println("-----------------");

​        s=**new** ConcreteStrategyB();

​        c.setStrategy(s);

​        c.strategyMethod();

​    }

}

//抽象策略类

**interface** **Strategy**

{   

​    **public** **void** **strategyMethod**();    //策略方法

}

//具体策略类A

**class** **ConcreteStrategyA** **implements** **Strategy**

{

​    **public** **void** **strategyMethod**()

​    {

​        System.out.println("具体策略A的策略方法被访问！");

​    }

}

//具体策略类B

**class** **ConcreteStrategyB** **implements** **Strategy**

{

  **public** **void** **strategyMethod**()

  {

​      System.out.println("具体策略B的策略方法被访问！");

  }

}

//环境类

**class** **Context**

{

​    **private** Strategy strategy;

​    **public** Strategy **getStrategy**()

​    {

​        **return** strategy;

​    }

​    **public** **void** **setStrategy**(Strategy strategy)

​    {

​        **this**.strategy=strategy;

​    }

​    **public** **void** **strategyMethod**()

​    {

​        strategy.strategyMethod();

​    }

}



程序运行结果如下：

Plain  Text

具体策略A的策略方法被访问！

\-----------------

具体策略B的策略方法被访问！

## 策略模式的应用实例

【例1】策略模式在“大闸蟹”做菜中的应用。



分析：关于大闸蟹的做法有很多种，我们以清蒸大闸蟹和红烧大闸蟹两种方法为例，介绍策略模式的应用。



首先，定义一个大闸蟹加工的抽象策略类（CrabCooking），里面包含了一个做菜的抽象方法 CookingMethod()；然后，定义清蒸大闸蟹（SteamedCrabs）和红烧大闸蟹（BraisedCrabs）的具体策略类，它们实现了抽象策略类中的抽象方法；由于本程序要显示做好的结果图，所以将具体策略类定义成 JLabel 的子类；最后，定义一个厨房（Kitchen）环境类，它具有设置和选择做菜策略的方法；客户类通过厨房类获取做菜策略，并把做菜结果图在窗体中显示出来，图 2 所示是其结构图。



![img](https://uploader.shimo.im/f/MZQxQUqcjV0HU5Sb.png!thumbnail)

图2 大闸蟹做菜策略的结构图



程序代码如下：

Java

**package** strategy;

**import** java.awt.*;

**import** java.awt.event.*;

**import** javax.swing.*;

**public** **class** **CrabCookingStrategy** **implements** **ItemListener**

{

​    **private** JFrame f;

​    **private** JRadioButton qz,hs;

​    **private** JPanel CenterJP,SouthJP;

​    **private** Kitchen cf;    //厨房

​    **private** CrabCooking qzx,hsx;    //大闸蟹加工者   

​    CrabCookingStrategy()

​    {

​        f=**new** JFrame("策略模式在大闸蟹做菜中的应用");

​        f.setBounds(100,100,500,400);

​        f.setVisible(**true**);       

​        f.setResizable(**false**);

​        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

​        SouthJP=**new** JPanel();

​        CenterJP=**new** JPanel();

​        f.add("South",SouthJP);

​        f.add("Center",CenterJP);

​        qz=**new** JRadioButton("清蒸大闸蟹");

​        hs=**new** JRadioButton("红烧大闸蟹");

​        qz.addItemListener(**this**);

​        hs.addItemListener(**this**);

​        ButtonGroup group=**new** ButtonGroup();

​        group.add(qz);

​        group.add(hs);

​        SouthJP.add(qz);

​        SouthJP.add(hs);

​        //---------------------------------

​        cf=**new** Kitchen();    //厨房

​        qzx=**new** SteamedCrabs();    //清蒸大闸蟹类

​        hsx=**new** BraisedCrabs();    //红烧大闸蟹类

​    }

​    **public** **void** **itemStateChanged**(ItemEvent e)

​    {

​        JRadioButton jc=(JRadioButton) e.getSource();

​        **if**(jc==qz)

​        {

​            cf.setStrategy(qzx);

​            cf.CookingMethod(); //清蒸

​        }

​        **else** **if**(jc==hs)

​        {

​            cf.setStrategy(hsx);

​            cf.CookingMethod(); //红烧

​        }

​        CenterJP.removeAll();

​        CenterJP.repaint();

​        CenterJP.add((Component)cf.getStrategy());       

​        f.setVisible(**true**);

​    }

​    **public** **static** **void** **main**(String[] args)

​    {       

​        **new** CrabCookingStrategy();

​    }

}

//抽象策略类：大闸蟹加工类

**interface** **CrabCooking**

{

​    **public** **void** **CookingMethod**();    //做菜方法

}

//具体策略类：清蒸大闸蟹

**class** **SteamedCrabs** **extends** **JLabel** **implements** **CrabCooking**

{

​    **private** **static** **final** **long** serialVersionUID=1L;

​    **public** **void** **CookingMethod**()

​    {

​          **this**.setIcon(**new** ImageIcon("src/strategy/SteamedCrabs.jpg"));

​          **this**.setHorizontalAlignment(CENTER);

​    }

}

//具体策略类：红烧大闸蟹

**class** **BraisedCrabs** **extends** **JLabel** **implements** **CrabCooking**

{

​    **private** **static** **final** **long** serialVersionUID=1L;

​    **public** **void** **CookingMethod**()

​    {

​        **this**.setIcon(**new** ImageIcon("src/strategy/BraisedCrabs.jpg"));

​        **this**.setHorizontalAlignment(CENTER);

​    }

}

//环境类：厨房

**class** **Kitchen**

{

​    **private** CrabCooking strategy;    //抽象策略

​    **public** **void** **setStrategy**(CrabCooking strategy)

​    {

​        **this**.strategy=strategy;

​    }

​    **public** CrabCooking **getStrategy**()

​    {

​        **return** strategy;

​    }

​    **public** **void** **CookingMethod**()

​    {

​        strategy.CookingMethod();    //做菜   

​    }

}



程序运行结果如图 3 所示。



![img](https://uploader.shimo.im/f/G3dcXhuxnNz9PE6S.png!thumbnail)

图3 大闸蟹做菜结果



【例2】用策略模式实现从韶关去婺源旅游的出行方式。



分析：从韶关去婺源旅游有以下几种出行方式：坐火车、坐汽车和自驾车，所以该实例用策略模式比较适合，图 4 所示是其结构图。



![img](https://uploader.shimo.im/f/p2zmhSWUjHwonPvc.png!thumbnail)

图4 婺源旅游结构图

## 策略模式的应用场景

策略模式在很多地方用到，如 Java SE 中的容器布局管理就是一个典型的实例，Java SE 中的每个容器都存在多种布局供用户选择。在程序设计中，通常在以下几种情况中使用策略模式较多。

1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。

1. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。

1. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。

1. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构

1. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。

## 策略模式的扩展

在一个使用策略模式的系统中，当存在的策略很多时，客户端管理所有策略算法将变得很复杂，如果在环境类中使用策略工厂模式来管理这些策略类将大大减少客户端的工作复杂度，其结构图如图 5 所示。



![img](https://uploader.shimo.im/f/ZdPouYWN0wpiateq.png!thumbnail)

图5 策略工厂模式的结构图





1. UML

## 统一建模语言简介

统一建模语言（Unified Modeling Language，UML）是用来设计软件蓝图的可视化建模语言，1997 年被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。



统一建模语言能为软件开发的所有阶段提供模型化和可视化支持。而且融入了软件工程领域的新思想、新方法和新技术，使软件设计人员沟通更简明，进一步缩短了设计时间，减少开发成本。它的应用领域很宽，不仅适合于一般系统的开发，而且适合于并行与分布式系统的建模。



UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。



本教程主要介绍软件设计模式中经常用到的类图，以及类之间的关系。另外，在实验部分将简单介绍 UML 建模工具的使用方法，当前业界使用最广泛的是 Rational Rose。使用 Umlet 的人也很多，它是一个轻量级的开源 UML 建模工具，简单实用，常用于小型软件系统的开发与设计。

## 类、接口和类图

#### 1. 类

类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。



(1) 类名（Name）是一个字符串，例如，Student。



(2) 属性（Attribute）是指类的特性，即类的成员变量。UML 按以下格式表示：

Plain  Text

[可见性]属性名:类型[=默认值]

例如：-name:String



注意：“可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）4 种，在类图中分别用符号+、-、#、~表示。



(3) 操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。UML 按以下格式表示：

Plain  Text

[可见性]名称(参数列表)[:返回类型]

例如：+display():void。



图 1 所示是学生类的 UML 表示。



![img](https://uploader.shimo.im/f/YRPXa08L939Zf5tN.png!thumbnail)

图1 Student 类

#### 2. 接口

接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。



图 2 所示是图形类接口的 UMDL 表示。



![img](https://uploader.shimo.im/f/GyRKRxbMMoHYEpii.png!thumbnail)

图2 Graph 接口

#### 3. 类图

类图（ClassDiagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。它主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，它是系统分析与设计阶段的重要产物，也是系统编码与测试的重要模型依据。



类图中的类可以通过某种编程 语言直接实现。类图在软件系统开发的整个生命周期都是有效的，它是面向对象系统的建模中最常见的图。图 3 所示是“计算长方形和圆形的周长与面积”的类图，图形接口有计算面积和周长的抽象方法，长方形和圆形实现这两个方法供访问类调用。



![img](https://uploader.shimo.im/f/9mXbVuhoigPFMwI7.png!thumbnail)

图3 “计算长方形和圆形的周长与面积”的类图

## 类之间的关系

在软件系统中，类不是孤立存在的，类与类之间存在各种关系。根据类与类之间的耦合度从弱到强排列，UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。1. 依赖关系

依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。



在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。图 4 所示是人与手机的关系图，人通过手机的语音传送方法打电话。



![img](https://uploader.shimo.im/f/4AQnDoNgrVZdxO0r.png!thumbnail)

图4 依赖关系的实例

#### 2. 关联关系

关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。



关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。



在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。图 5 所示是老师和学生的关系图，每个老师可以教多个学生，每个学生也可向多个老师学，他们是双向关联。



![img](https://uploader.shimo.im/f/N6ag8qmITbU7TtAf.png!thumbnail)

图5 关联关系的实例

#### 3. 聚合关系

聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。



聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。



在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。图 6 所示是大学和教师的关系图。



![img](https://uploader.shimo.im/f/dcCGaMynRXlpYLaC.png!thumbnail)

图6 聚合关系的实例

#### 4.组合关系

组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系。



在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。



在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。图 7 所示是头和嘴的关系图。



![img](https://uploader.shimo.im/f/WsiNO7oXkJCjuclE.png!thumbnail)

图7 组合关系的实例

#### 5.泛化关系

泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。



在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如图 8 所示。



![img](https://uploader.shimo.im/f/ja6WeSFCtaStefQ5.png!thumbnail)

图8 泛化关系的实例

#### 6.实现关系

实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。



在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图 9 所示。



![img](https://uploader.shimo.im/f/Wm5wX2WwnpZFTuHz.png!thumbnail)

图9 实现关系的实例



# 8.开闭原则

## 开闭原则的定义

开闭原则（Open Closed Principle，OCP）由勃兰特·梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object Oriented Software Construction）中提出：软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。



这里的软件实体包括以下几个部分：

1. 项目中划分出的模块

1. 类与接口

1. 方法



**开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。开闭原则的作用**



开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。

#### 1. 对软件测试的影响

软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。

#### 2. 可以提高代码的可复用性

粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。

#### 3. 可以提高软件的可维护性

遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。

## 开闭原则的实现方法

可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。



因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。



下面以 Windows 的桌面主题为例介绍开闭原则的应用。



【例1】Windows 的桌面主题设计。



分析：Windows 的主题是桌面背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的桌面主题，也可以从网上下载新的主题。这些主题有共同的特点，可以为其定义一个抽象类（Abstract Subject），而每个具体的主题（Specific Subject）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的，其类图如图 1 所示。



![img](https://uploader.shimo.im/f/i9oI4u19igEF56LD.png!thumbnail)

图1 Windows的桌面主题类图