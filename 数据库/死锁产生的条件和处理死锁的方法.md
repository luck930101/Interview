# **死锁是什么**

**死锁（Deadlock）**就是指两个或两个以上的进程在执行的过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去，此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

------

# **死锁发生的条件**

若可能发生死锁，则必定要出现三个条件：

**1. 互斥条件：** 指进程对所分配的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直到占有资源的进程用完后释放资源。

**2. 占有且等待条件：** 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程阻塞，但它不会释放自己已经占有的资源。

**3.非抢占条件：** 指进程已经获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。

满足以上三个条件可能会产生死锁，但如果只有这三个条件，则不一定产生死锁。对死锁的产生，还需要第四个条件。

**4.循环等待条件** 存在一个封闭的进程链，使得每个资源至少占有此链中下一个进程所需要的一个资源。

前三个条件是死锁存在的必要条件，但不是充分条件。第四个条件实际上是前三个条件的潜在结果，即假设前三个条件存在，可能发生的一系列事情会导致不可解的循环等待。这四个条件连在一起构成了死锁的充分必要条件。

------

# 死锁处理

有三种方法可以处理死锁。

- **第一种方法**：采用某种策略来消除条件1-4中的一个条件的出现来防止死锁**【死锁预防】**。
- **第二种方法**：基于资源分配的当前状态做动态选择来避免死锁**【死锁避免】**。
- **第三种方法**：试图去检测死锁的存在并试图从死锁中恢复出来**【死锁检测】**

### **死锁预防**

##### **破坏“互斥“条件**

就是在系统里取消互斥。若资源不被一个进程独占使用，那么死锁是肯定不会发生的。但一般来说，第一个条件是不可能被禁止的，比如打印机等临界资源只能互斥使用。

##### **破坏“占有并等待”条件**

就是在系统中不允许进程在已获得某种资源的情况下，申请其他资源，要求进程一次性地请求所有需要的资源，并且阻塞这个进程直到所有请求都同时满足。

这样做有几个个缺陷，会很低效：

- 一个进程可能被阻塞很长时间，等待满足其所有的资源请求，而实际上，只要有一部分资源，它就可以继续执行。
- 分配给一个进程的资源可能有相当长的一段时间处于不可用状态，并且再次期间，它们不能被其他进程使用。
- 一个进程可能事先并不会知道它所需要的所有资源。
- \-

##### **破坏“非抢占“条件**

如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占用的资源，如果有必要，可再次请求这些资源和另外的资源。
另一种方法是，要求两个进程不具有相同的优先级时才能有效预防死锁。即如果一个进程请求当前另外一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。

上述这两种方法只有在资源状态可以很容易地保存和恢复的情况下（如处理器），比较实用。

##### **破坏“循环等待“条件**

循环等待条件可以通过定义资源类型的线性顺序来预防。如果一个进程已经分配到了R 类型的资源，那么接下来请求的资源只能是那些排在R 类型之后的资源类型。

### **死锁避免**

死锁避免是属于事先预防策略，但并不会事先采取某种措施破坏死锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。这种方法限制条件比较弱，可以获得较好的系统性能。

- 如果一个进程的请求会导致死锁，则不启动此进程。
- 如果一个进程增加资源的请求会导致死锁，则不允许此分配。

最著名的死锁避免算法**银行家算法**。

### **死锁检测与解除**

死锁预防和死锁避免嗾使以牺牲系统效率和浪费资源为代价的，这与操作系统的设计目标相违背。而**死锁检测**策略则完全相反，它不采取任何限制错误来保证系统不进入死锁状态，即允许死锁发生，但操作系统不断地监督进程的进程路径，判断死锁是否真的发生，一旦死锁发生，则采取专门的措施解除死锁，并以最小代价使得整个系统恢复正常。

死锁解除可分为以下两类：

1. 剥夺资源
2. 撤销进程

------

**总结**：死锁是指一组争用系统资源或相互通信的进程被阻塞的现象。阻塞是永久的，除非操作系统采取某些非常的行动，如杀死一个或多个进程，或者强迫一个或多个进程沿原路返回。

处理死锁通常有三种方法：预防、检测和避免。死锁预防通过确保死锁的一个必要条件不会满足，保证不会发生死锁。如果操作系统总是同一资源请求，则需要死锁检测。操作系统必须周期性地检测死锁，并采取行动破坏死锁。